<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-5351135917838281",enable_page_level_ads:!0})</script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css?v=1.0.2"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0"><link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-5351135917838281",enable_page_level_ads:!0})</script><script>!function(e,t,o,c,i,a,d){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),d=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",d.parentNode.insertBefore(a,d)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/b6dbddb6.js","daovoice"),daovoice("init",{app_id:"1adb1866"}),daovoice("update")</script><meta name="description" content="二分查找算法基本介绍 前面介绍的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间O(log2n) ，即查找到需要的目标位置最多只需要log2n 步，假设从[0,99]的队列(100 个数，即n=100)中寻到目标数30，则需要查找步数为log2100 , 即最多"><meta name="keywords" content="算法,二分查找算法"><meta property="og:type" content="article"><meta property="og:title" content="重学Java数据结构和算法（常用算法）"><meta property="og:url" content="https://lijingyuan.top/重学Java数据结构和算法（常用算法）.html"><meta property="og:site_name" content="丽璟园"><meta property="og:description" content="二分查找算法基本介绍 前面介绍的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间O(log2n) ，即查找到需要的目标位置最多只需要log2n 步，假设从[0,99]的队列(100 个数，即n=100)中寻到目标数30，则需要查找步数为log2100 , 即最多"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/fenzhimoshi.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/dongtaitujie.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp2.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp3.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp4.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp5.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp6.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp7.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp8.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp9.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp10.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp11.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp12.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp13.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/tanxin1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/tanxin2.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/tanxin3.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu2.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu3.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klskyingyong.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie2.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie3.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie4.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/djstlfenxi.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi2.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi3.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi4.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi5.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/qipan1.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/qipan2.jpg"><meta property="og:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/qipan3.jpg"><meta property="og:updated_time" content="2019-08-13T01:16:55.534Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="重学Java数据结构和算法（常用算法）"><meta name="twitter:description" content="二分查找算法基本介绍 前面介绍的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间O(log2n) ，即查找到需要的目标位置最多只需要log2n 步，假设从[0,99]的队列(100 个数，即n=100)中寻到目标数30，则需要查找步数为log2100 , 即最多"><meta name="twitter:image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/fenzhimoshi.jpg"><link rel="alternate" href="/atom.xml" title="丽璟园" type="application/atom+xml"><link rel="canonical" href="https://lijingyuan.top/重学Java数据结构和算法（常用算法）"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>重学Java数据结构和算法（常用算法） | 丽璟园</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b0c8ff4971347a7879ff82302af68b74";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">丽璟园</span><span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header> <a href="https://github.com/kangjinghang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lijingyuan.top/重学Java数据结构和算法（常用算法）.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="kangjinghang"><meta itemprop="description" content="不安便求安，安之又思变。"><meta itemprop="image" content="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/static/headImg-li.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="丽璟园"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">重学Java数据结构和算法（常用算法）</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-07 10:21:09" itemprop="dateCreated datePublished" datetime="2019-08-07T10:21:09+08:00">2019-08-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-13 09:16:55" itemprop="dateModified" datetime="2019-08-13T09:16:55+08:00">2019-08-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构和算法/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">评论数：</span><a href="/重学Java数据结构和算法（常用算法）.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/重学Java数据结构和算法（常用算法）.html" itemprop="commentCount"></span></a></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数：<span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></span><br><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span title="本文字数">40k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">37 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5351135917838281" data-ad-slot="5827056535" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>前面介绍的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式</li><li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</li><li>二分查找法的运行时间为对数时间O(log<sub>2</sub>n) ，即查找到需要的目标位置最多只需要log<sub>2</sub>n 步，假设从[0,99]的队列(100 个数，即n=100)中寻到目标数30，则需要查找步数为log<sub>2</sub>100 , 即最多需要查找7 次( 2^6 &lt; 100 &lt; 2^7)</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>要求：</strong>对数组{1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecur</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找的非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待查找的数组, arr 是升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 需要查找的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应下标，-1 表示没有找到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 说明要继续查找</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 需要向左边查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 需要向右边查找</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><p>分治算法可以求解的一些经典问题：</p><ul><li>二分搜索</li><li>大整数乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p><ol><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解。</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/fenzhimoshi.jpg" alt="分治算法"></p><h2 id="应用场景-汉诺塔"><a href="#应用场景-汉诺塔" class="headerlink" title="应用场景-汉诺塔"></a>应用场景-汉诺塔</h2><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。<br>假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol><li><p>如果是有一个盘， A-&gt;C</p><p>如果我们有n &gt;= 2 情况，我们总是可以看做是两个盘1.最下边的盘2. 上面的盘</p></li><li><p>先把最上面的盘A-&gt;B</p></li><li><p>把最下边的盘A-&gt;C</p></li><li><p>把B 塔的所有盘从B-&gt;C</p></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoitower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 汉诺塔的移动的方法</span></span><br><span class="line"><span class="comment">     * 使用分治算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有n &gt;= 2 情况，我们总是可以看做是两个盘1.最下边的一个盘2. 上面的所有盘</span></span><br><span class="line">            <span class="comment">//1. 先把最上面的所有盘A-&gt;B， 移动过程会使用到c</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//2. 把最下边的盘A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">            <span class="comment">//3. 把B 塔的所有盘从B-&gt;C , 移动过程使用到a 塔</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</li><li>动态规划可以通过填表的方式来逐步推进，得到最优解</li></ul><h2 id="应用场景-背包问题"><a href="#应用场景-背包问题" class="headerlink" title="应用场景-背包问题"></a>应用场景-背包问题</h2><p>有一个背包，容量为4 磅， 现有如下物品</p><table><thead><tr><th>物品</th><th>重量</th><th>价格</th></tr></thead><tbody><tr><td>吉他（G）</td><td>1</td><td>1500</td></tr><tr><td>音响（S）</td><td>4</td><td>3000</td></tr><tr><td>电脑（L）</td><td>3</td><td>2000</td></tr></tbody></table><ul><li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li><li>要求装入的物品不能重复</li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><ol><li><p>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01 背包和完全背包(完全背包指的是：每种物品都有无限件可用)</p></li><li><p>这里的问题属于01 背包，即每个物品最多放一个。而无限背包可以转化为01 背包。</p></li><li><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i 个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n 个物品，设v[i]、w[i]分别为第i 个物品的价值和重量，C 为背包的容量。再令v[i][j]表示在前i 个物品中能够装入容量为j 的背包中的最大价值。则我们有下面的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) v[i][<span class="number">0</span>]=v[<span class="number">0</span>][j]=<span class="number">0</span>; <span class="comment">//表示填入表第一行和第一列是0</span></span><br><span class="line">(<span class="number">2</span>) 当w[i]&gt; j 时：v[i][j]=v[i-<span class="number">1</span>][j] <span class="comment">// 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个</span></span><br><span class="line">单元格的装入策略</span><br><span class="line">(<span class="number">3</span>) 当j&gt;=w[i]时： v[i][j]=max&#123;v[i-<span class="number">1</span>][j], v[i]+v[i-<span class="number">1</span>][j-w[i]]&#125;</span><br><span class="line"><span class="comment">// 当准备加入的新增的商品的容量小于等于当前背包的容量,</span></span><br><span class="line"><span class="comment">// 装入的方式:</span></span><br><span class="line">v[i-<span class="number">1</span>][j]： 就是上一个单元格的装入的最大值</span><br><span class="line">v[i] : 表示当前商品的价值</span><br><span class="line">v[i-<span class="number">1</span>][j-w[i]] ： 装入i-<span class="number">1</span> 商品，到剩余空间j-w[i]的最大值</span><br><span class="line">当j&gt;=w[i]时： v[i][j]=max&#123;v[i-<span class="number">1</span>][j], v[i]+v[i-<span class="number">1</span>][j-w[i]]&#125; :</span><br></pre></td></tr></table></figure><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/dongtaitujie.jpg" alt="动态规划算法"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//物品的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//物品的价值这里val[i] 就是前面讲的v[i]</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//物品的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length;</span><br><span class="line">        <span class="comment">//创建二维数组，</span></span><br><span class="line">        <span class="comment">//v[i][j] 表示在前i 个物品中能够装入容量为j 的背包中的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将第一列设置为0</span></span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="comment">//将第一行设置0</span></span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面得到公式来动态规划处理</span></span><br><span class="line">        <span class="comment">//不处理第一行i 是从1 开始的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="comment">//不处理第一列, j 是从1 开始的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    <span class="comment">// 因为我们程序i 是从1 开始的，因此原来公式中的w[i] 修改成w[i-1]</span></span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//因为我们的i 从1 开始的， 因此公式需要调整成</span></span><br><span class="line">                    <span class="comment">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else 来体现公式</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//把当前的情况记录到path</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">        <span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line">        <span class="comment">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span></span><br><span class="line">        <span class="comment">//行的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//列的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从path 的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"第%d 个商品放入到背包\n"</span>, i);</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>字符串匹配问题：<br>1) 有一个字符串str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串str2=”ABCDABD”<br>2) 现在要判断str1 是否含有str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p><h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><p>如果用暴力匹配的思路，并假设现在str1 匹配到i 位置，子串str2 匹配到j 位置，则有:</p><ul><li>如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符</li><li>如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li><li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力匹配算法实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s1Len = s1.length;</span><br><span class="line">        <span class="keyword">int</span> s2Len = s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 索引指向s1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// j 索引指向s2</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证匹配时，不越界</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">                <span class="comment">// 匹配成功</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有匹配成功</span></span><br><span class="line">                <span class="comment">// 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j == s2Len) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li><li>Knuth-Morris-Pratt 字符串查找算法，简称为“KMP 算法”，常用于在一个文本串S 内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris 三人于1977 年联合发表，故取这3 人的姓氏命名此算法.</li><li>KMP 方法算法就利用之前判断过信息，通过一个next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next 数组找到，前面匹配过的位置，省去了大量的计算时间</li><li>参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></li></ul><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>举例来说，有一个字符串Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串Str2 =“ABCDABD”？</p><ol><li><p>首先，用Str1 的第一个字符和Str2 的第一个字符去比较，不符合，关键词向后移动一位</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp1.jpg" alt="KMP算法"></p></li><li><p>重复第一步，还是不符合，再后移</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp2.jpg" alt="KMP算法"></p></li><li><p>一直重复，直到Str1 有一个字符与Str2 的第一个字符符合为止</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp3.jpg" alt="KMP算法"></p></li><li><p>接着比较字符串和搜索词的下一个字符，还是符合</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp4.jpg" alt="KMP算法"></p></li><li><p>遇到Str1 有一个字符与Str2 对应的字符不符合</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp5.jpg" alt="KMP算法"></p></li><li><p>这时候，想到的是继续遍历Str1 的下一个字符，重复第1 步。(其实是很不明智的，因为此时BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D 不匹配时，你其实知道前面六个字符是”ABCDAB”。<br>KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。)</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp6.jpg" alt="KMP算法"></p></li><li><p>怎么做到把刚刚重复的步骤省略掉？可以对Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp7.jpg" alt="KMP算法"></p></li><li><p>已知空格与D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B 对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：<br>移动位数= 已匹配的字符数- 对应的部分匹配值<br>因为6 - 2 等于4，所以将搜索词向后移动4 位。</p></li><li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数= 2 - 0，结果为2，于是将搜索词向后移2 位。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp8.jpg" alt="KMP算法"></p></li><li><p>因为空格与A 不匹配，继续后移一位</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp9.jpg" alt="KMP算法"></p></li><li><p>逐位比较，直到发现C 与D 不匹配。于是，移动位数= 6 - 2，继续将搜索词向后移动4 位</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp10.jpg" alt="KMP算法"></p></li><li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数= 7 - 0，再将搜索词向后移动7 位，这里就不再重复了。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp11.jpg" alt="KMP算法"></p></li><li><p>介绍《部分匹配表》怎么产生的<br>先介绍前缀，后缀是什么</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp12.jpg" alt="KMP算法"></p><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p><ul><li>”A”的前缀和后缀都为空集，共有元素的长度为0；</li><li>”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li><li>”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li><li>”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li><li>”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li><li>”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li><li>”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD,D]，共有元素的长度为0。</li></ul></li><li><p>”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/kmp13.jpg" alt="KMP算法"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kmp 搜索算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是-1 就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//需要处理str1.charAt(i) ！= str2.charAt(j), 去调整j 的大小</span></span><br><span class="line">            <span class="comment">//KMP 算法核心点, 可以验证...</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                <span class="comment">//找到了// j = 3 i</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到一个字符串(子串) 的部分匹配值表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="comment">//创建一个next 数组保存部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        <span class="comment">//如果字符串是长度为1 部分匹配值就是0</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现有dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这是kmp 算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</li><li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li></ul><h2 id="应用场景-集合覆盖"><a href="#应用场景-集合覆盖" class="headerlink" title="应用场景-集合覆盖"></a>应用场景-集合覆盖</h2><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/tanxin1.jpg" alt="贪心算法"></p><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n 个广播台，则广播台的组合总共有2<sup>n</sup> -1 个,假设每秒可以计算10 个子集， 如图:</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/tanxin2.jpg" alt="贪心算法"></p><p>使用贪心算法，效率高：</p><ol><li>目前并没有算法可以快速计算得到准备的值， 使用贪心算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:</li><li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）</li><li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li><li>重复第1 步直到覆盖了全部的地区</li></ol><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/tanxin3.jpg" alt="贪心算法"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建广播电台,放入到Map</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">"北京"</span>);</span><br><span class="line">        hashSet1.add(<span class="string">"上海"</span>);</span><br><span class="line">        hashSet1.add(<span class="string">"天津"</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">"广州"</span>);</span><br><span class="line">        hashSet2.add(<span class="string">"北京"</span>);</span><br><span class="line">        hashSet2.add(<span class="string">"深圳"</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">"成都"</span>);</span><br><span class="line">        hashSet3.add(<span class="string">"上海"</span>);</span><br><span class="line">        hashSet3.add(<span class="string">"杭州"</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">"上海"</span>);</span><br><span class="line">        hashSet4.add(<span class="string">"天津"</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">"杭州"</span>);</span><br><span class="line">        hashSet5.add(<span class="string">"大连"</span>);</span><br><span class="line">        <span class="comment">//加入到map</span></span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//allAreas 存放所有的地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        allAreas.add(<span class="string">"北京"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"上海"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"天津"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"广州"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"深圳"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"成都"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"杭州"</span>);</span><br><span class="line">        allAreas.add(<span class="string">"大连"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList, 存放选择的电台集合</span></span><br><span class="line">        ArrayList&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line">        <span class="comment">//如果maxKey 不为null , 则会加入到selects</span></span><br><span class="line">        String maxKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span></span><br><span class="line">        <span class="keyword">while</span> (allAreas.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//每进行一次while,需要</span></span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//遍历broadcasts, 取出对应key</span></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                <span class="comment">//每进行一次for</span></span><br><span class="line">                tempSet.clear();</span><br><span class="line">                <span class="comment">//当前这个key 能够覆盖的地区</span></span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出tempSet 和allAreas 集合的交集, 交集会赋给tempSet</span></span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line">                <span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey 指向的集合地区还多</span></span><br><span class="line">                <span class="comment">//就需要重置maxKey</span></span><br><span class="line">                <span class="comment">// tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//maxKey != null, 就应该将maxKey 加入selects</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">//将maxKey 指向的广播电台覆盖的地区，从allAreas 去掉</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//[K1,K2,K3,K5]</span></span><br><span class="line">        System.out.println(<span class="string">"得到的选择结果是"</span> + selects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li><li>比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区</li><li>但是我们发现K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的K1, K2, K3,K5 虽然是满足条件，但是并不是最优的</li></ul><h1 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h1><h2 id="应用场景-修路问题"><a href="#应用场景-修路问题" class="headerlink" title="应用场景-修路问题"></a>应用场景-修路问题</h2><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu1.jpg" alt="普利姆算法"></p><ol><li>有胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把7 个村庄连通</li><li>各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里</li><li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</li></ol><p><strong>思路：</strong> 将10 条边，连接即可，但是总的里程数不是最小.<br>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少。</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树。</p><ul><li><p>N 个顶点，一定有N-1 条边</p></li><li><p>包含全部顶点</p></li><li><p>N-1 条边都在图中</p></li><li><p>举例说明(如图)</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu2.jpg" alt="普利姆算法"></p></li><li><p>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</p></li></ul><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>普利姆(Prim)算法求最小生成树，也就是在包含n 个顶点的连通图中，找出只有(n-1)条边包含所有n 个顶点的连通子图，也就是所谓的极小连通子图。<br>普利姆的算法如下:</p><ol><li><p>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合</p></li><li><p>若从顶点u 开始构造最小生成树，则从集合V 中取出顶点u 放入集合U 中，标记顶点v 的visited[u]=1</p></li><li><p>若集合U 中顶点ui 与集合V-U 中的顶点vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj 加入集合U 中，将边（ui,vj）加入集合D 中，标记visited[vj]=1</p></li><li><p>重复步骤②，直到U 与V 相等，即所有顶点都被标记为访问过，此时D 中有n-1 条边</p></li><li><p>提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.</p></li><li><p>图解普利姆算法</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu3.jpg" alt="普利姆算法"></p></li></ol><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> vertexs = data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示,10000 这个大数，表示两个点不联通</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10000</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//创建MGraph 对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(vertexs);</span><br><span class="line">        <span class="comment">//创建一个MinTree 对象</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, vertexs, data, weight);</span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        minTree.prim(graph, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建最小生成树-&gt;村庄的图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph   图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexs 图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph, <span class="keyword">int</span> vertexs, <span class="keyword">char</span> data[], <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexs; i++) &#123;</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写prim 算法，得到最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//visited[] 标记结点(顶点)是否被访问过</span></span><br><span class="line">        <span class="comment">//visited[] 默认元素的值都是0, 表示没有访问过</span></span><br><span class="line">        <span class="keyword">int</span> visited[] = <span class="keyword">new</span> <span class="keyword">int</span>[graph.vertexs];</span><br><span class="line">        <span class="comment">//把当前这个结点标记为已访问</span></span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//h1 和h2 记录两个顶点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将minWeight 初始成一个大数，后面在遍历过程中，会被替换</span></span><br><span class="line">        <span class="keyword">int</span> minWeight = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//因为有graph.verxs 顶点，普利姆算法结束后，有graph.verxs-1 边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.vertexs; k++) &#123;</span><br><span class="line">            <span class="comment">//这个是确定每一次生成的子图，和哪个结点的距离最近</span></span><br><span class="line">            <span class="comment">// i 结点表示被访问过的结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexs; i++) &#123;</span><br><span class="line">                <span class="comment">//j 结点表示还没有访问过的结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexs; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[i] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line">                        <span class="comment">//替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span></span><br><span class="line">                        minWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一条边是最小</span></span><br><span class="line">            System.out.println(<span class="string">"边&lt;"</span> + graph.data[h1] + <span class="string">","</span> + graph.data[h2] + <span class="string">"&gt; 权值:"</span> + minWeight);</span><br><span class="line">            <span class="comment">//将当前这个结点标记为已经访问</span></span><br><span class="line">            visited[h2] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//minWeight 重新设置为最大值10000</span></span><br><span class="line">            minWeight = <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示图的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> vertexs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放结点数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放边，就是我们的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> vertexs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexs = vertexs;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[vertexs];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="keyword">int</span>[vertexs][vertexs];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h1><h2 id="应用场景-公交站问题"><a href="#应用场景-公交站问题" class="headerlink" title="应用场景-公交站问题"></a>应用场景-公交站问题</h2><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klskyingyong.jpg" alt="克鲁斯卡尔问题"></p><ol><li><p>某城市新增7 个站点(A, B, C, D, E, F, G) ，现在需要修路把7 个站点连通</p></li><li><p>各个站点的距离用边线表示(权) ，比如A – B 距离12 公里</p></li><li><p>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?</p></li></ol><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</li><li>基本思想：按照权值从小到大的顺序选择n-1 条边，并保证这n-1 条边不构成回路。</li><li>具体做法：首先构造一个只含n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</li></ul><h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>以城市公交站问题来图解说明克鲁斯卡尔算法的原理和步骤：</p><p>在含有n 个顶点的连通图中选择n-1 条边，构成一棵极小连通子图，并使该连通子图中n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie1.jpg" alt="克鲁斯卡尔问题"></p><p>例如，对于如上图G4 所示的连通网可以有多棵权值总和不相同的生成树。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie2.jpg" alt="克鲁斯卡尔问题"></p><h3 id="图解说明"><a href="#图解说明" class="headerlink" title="图解说明"></a>图解说明</h3><p>以上图G4 为例，来对克鲁斯卡尔进行演示(假设，用数组R 保存最小生成树结果)。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie3.jpg" alt="克鲁斯卡尔问题"></p><ol><li><p>将边&lt;E,F&gt;加入R 中。</p><p>边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R 中。</p></li><li><p>将边&lt;C,D&gt;加入R 中。</p><p>上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R 中。</p></li><li><p>将边&lt;D,E&gt;加入R 中。</p><p>上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R 中。</p></li><li><p>将边&lt;B,F&gt;加入R 中。</p><p>上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R 中。</p></li><li><p>将边&lt;E,G&gt;加入R 中。</p><p>上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R 中。</p></li><li><p>将边&lt;A,B&gt;加入R 中。</p><p>上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R 中。</p></li></ol><p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br>问题一：对图的所有边按照权值大小进行排序。<br>问题二：将边添加到最小生成树中时，怎么样判断是否形成了回路。<br>问题一很好解决，采用排序算法进行排序即可。<br>问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p><h3 id="回路问题"><a href="#回路问题" class="headerlink" title="回路问题"></a>回路问题</h3><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/klsktujie4.jpg" alt="克鲁斯卡尔问题"></p><p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R 中之后，这几条边的顶点就都有了终点：</p><ul><li>C 的终点是F。</li><li>D 的终点是F。</li><li>E 的终点是F。</li><li>F 的终点是F。</li></ul><p>关于终点的说明：</p><ol><li>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。</li><li>因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C 和E 的终点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】</li></ol><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertexs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用INF 表示两个顶点不能连通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> matrix[][] = &#123;</span><br><span class="line">                <span class="comment">/*A*/</span> &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                <span class="comment">/*B*/</span> &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span> &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*D*/</span> &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                <span class="comment">/*E*/</span> &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                <span class="comment">/*F*/</span> &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                <span class="comment">/*G*/</span> &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        KruskalCase kruskalCase = <span class="keyword">new</span> KruskalCase(vertexs, matrix);</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalCase</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数和边的个数</span></span><br><span class="line">        <span class="keyword">int</span> vlen = vertexs.length;</span><br><span class="line">        <span class="comment">//初始化顶点, 复制拷贝的方式</span></span><br><span class="line">        <span class="keyword">this</span>.vertexs = <span class="keyword">new</span> <span class="keyword">char</span>[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化边, 使用的是复制拷贝的方式</span></span><br><span class="line">        <span class="keyword">this</span>.matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计边的条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"邻接矩阵为: \n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%12d"</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示最后结果数组的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点</span></span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum];</span><br><span class="line">        <span class="comment">//创建结果数组, 保存最后的最小生成树</span></span><br><span class="line">        EData[] res = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line">        <span class="comment">//获取图中所有的边的集合， 一共有12 边</span></span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        System.out.println(<span class="string">"图的边的集合="</span> + Arrays.toString(edges) + <span class="string">" 共"</span> + edges.length);</span><br><span class="line">        <span class="comment">//按照边的权值大小进行排序(从小到大)</span></span><br><span class="line">        sortEdges(edges);</span><br><span class="line">        <span class="comment">//遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入res,否则不能加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到第i 条边的第一个顶点(起点)</span></span><br><span class="line">            <span class="keyword">int</span> p1 = getPosition(edges[i].start);</span><br><span class="line">            <span class="comment">//获取到第i 条边的第2 个顶点(终点)</span></span><br><span class="line">            <span class="keyword">int</span> p2 = getPosition(edges[i].end);</span><br><span class="line">            <span class="comment">//获取p1 这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> m = getEnd(ends, p1);</span><br><span class="line">            <span class="comment">//获取p2 这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p2);</span><br><span class="line">            <span class="comment">//是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">                <span class="comment">//没有构成回路</span></span><br><span class="line">                <span class="comment">// 设置m 在"已有最小生成树"中的终点&lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line">                ends[m] = n;</span><br><span class="line">                <span class="comment">//有一条边加入到res 数组</span></span><br><span class="line">                res[index++] = edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计并打印"最小生成树", 输出rets</span></span><br><span class="line">        System.out.println(<span class="string">"最小生成树为"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对边进行排序处理, 冒泡排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges 边的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortEdges</span><span class="params">(EData[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">                    EData temp = edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能: 获取下标为i 的顶点的终点, 用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是下标为i 的这个顶点对应的终点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 顶点的值，比如'A','B'</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ch 顶点对应的下标，如果找不到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertexs[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组是通过matrix 邻接矩阵来获取</span></span><br><span class="line"><span class="comment">     * EData[] 形式[['A','B', 12], ['B','F',7], .....]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] getEdges() &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        EData[] edges = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = <span class="keyword">new</span> EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个类EData ，它的对象实例就表示一条边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边的起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边的终点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边的权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EData</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"EData [&lt;"</span> + start + <span class="string">", "</span> + end + <span class="string">"&gt;= "</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h1><h2 id="应用场景-最短路径问题"><a href="#应用场景-最短路径问题" class="headerlink" title="应用场景-最短路径问题"></a>应用场景-最短路径问题</h2><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu1.jpg" alt="迪杰斯特拉算法"></p><ol><li><p>胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G 点出发，需要分别把邮件分别送到A, B, C , D, E, F 六个村庄</p></li><li><p>各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里</p></li><li><p>问：如何计算出G 村庄到其它各个村庄的最短距离?</p></li><li><p>如果从其它点出发到各个点的最短距离又是多少?</p></li></ol><h2 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h2 id="思路分析-5"><a href="#思路分析-5" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li><p>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v 到V 中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v 到图中各顶点的距离(到自身可以看作0，v 到vi 距离对应为di)</p></li><li><p>从Dis 中选择值最小的di 并移出Dis 集合，同时移出V 集合中对应的顶点vi，此时的v 到vi 即为最短路径</p></li><li><p>更新Dis 集合，更新规则为：比较v 到V 集合中顶点的距离值，与v 通过vi 到V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi 到达的)</p></li><li><p>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/djstlfenxi.jpg" alt="迪杰斯特拉问题"></p></li></ol><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="comment">//邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="comment">// 表示不可以连接</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, N, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, N, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, N, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, N, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, N, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, N&#125;;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        graph.dsj(<span class="number">6</span>);</span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已经访问的顶点的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迪杰斯特拉算法实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 表示出发顶点对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dsj</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        vv = <span class="keyword">new</span> VisitedVertex(vertex.length, index);</span><br><span class="line">        <span class="comment">//更新index 顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">        update(index);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 选择并返回新的访问顶点</span></span><br><span class="line">            index = vv.updateArr();</span><br><span class="line">            <span class="comment">// 更新index 顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">            update(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vv.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新index 下标顶点到周围顶点的距离和周围顶点的前驱顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据遍历我们的邻接矩阵的matrix[index]行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="comment">// len 含义是: 出发顶点到index 顶点的距离 + 从index 顶点到j 顶点的距离的和</span></span><br><span class="line">            len = vv.getDis(index) + matrix[index][j];</span><br><span class="line">            <span class="comment">// 如果j 顶点没有被访问过，并且len 小于出发顶点到j 顶点的距离，就需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;</span><br><span class="line">                <span class="comment">//更新j 顶点的前驱为index 顶点</span></span><br><span class="line">                vv.updatePre(j, index);</span><br><span class="line">                <span class="comment">//更新出发顶点到j 顶点的距离</span></span><br><span class="line">                vv.updateDis(j, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已访问顶点集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录各个顶点是否访问过1 表示访问过,0 未访问,会动态更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] already_arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个下标对应的值为前一个顶点下标, 会动态更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] pre_visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录出发顶点到其他所有顶点的距离,比如G 为出发顶点，就会记录G 到其它顶点的距离，会动态更新，求</span></span><br><span class="line"><span class="comment">     * 的最短距离就会存放到dis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示顶点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  出发顶点对应的下标, 比如G 顶点，下标就是6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.already_arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.pre_visited = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.dis = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//初始化dis 数组</span></span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        <span class="comment">//设置出发顶点被访问过</span></span><br><span class="line">        <span class="keyword">this</span>.already_arr[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置出发顶点的访问距离为0</span></span><br><span class="line">        <span class="keyword">this</span>.dis[index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断index 顶点是否被访问过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新出发顶点到index 顶点的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDis</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新pre 这个顶点的前驱顶点为index 顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePre</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        pre_visited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回出发顶点到index 顶点的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继续选择并返回新的访问顶点，比如这里的G 完后，就是A 点作为新的访问顶点(注意不是出发顶点)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (already_arr[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新index 顶点被访问过</span></span><br><span class="line">        already_arr[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        <span class="comment">//输出already_arr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : already_arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出pre_visited</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : pre_visited) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出dis</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//为了好看最后的最短距离，我们处理</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">65535</span>) &#123;</span><br><span class="line">                System.out.print(vertex[count] + <span class="string">"("</span> + i + <span class="string">") "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"N "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h1><h2 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>和Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授<strong>罗伯特·弗洛伊德</strong>命名。</li><li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径。</li><li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li><li><strong>弗洛伊德算法VS 迪杰斯特拉算法</strong>：迪杰斯特拉算法通过选定的被访问顶点，求<strong>出从出发访问顶点到其他顶点的最短路径</strong>；弗洛伊德算法中<strong>每一个顶点都是出发访问点</strong>，所以需要将每一个顶点看做被访问顶点，求出<strong>从每一个顶点到其他顶点的最短路径</strong>。</li></ul><h2 id="思路分析-6"><a href="#思路分析-6" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li>设置顶点vi 到顶点vk 的最短路径已知为Lik，顶点vk 到vj 的最短路径已知为Lkj，顶点vi 到vj 的路径为Lij，则vi 到vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得vi 到vj 的最短路径。</li><li>至于vi 到vk 的最短路径Lik 或者vk 到vj 的最短路径Lkj，是以同样的方式获得。</li></ol><p>示例：求最短路径为例说明。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi1.jpg" alt="弗洛伊德算法"></p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi2.jpg" alt="弗洛伊德算法"></p><p>弗洛伊德算法的步骤：<br>第一轮循环中，以A(下标为：0)作为中间顶点【即把A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表和前驱关系】，<br>距离表和前驱关系更新为：</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi3.jpg" alt="弗洛伊德算法"></p><p>分析如下：</p><ol><li>以A 顶点作为中间顶点是，B-&gt;A-&gt;C 的距离由N-&gt;9，同理C 到B；C-&gt;A-&gt;G 的距离由N-&gt;12，同理G 到C</li><li>更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</li></ol><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi4.jpg" alt="弗洛伊德算法"></p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/flydfenxi5.jpg" alt="弗洛伊德算法"></p><h2 id="应用场景-最短路径问题-1"><a href="#应用场景-最短路径问题-1" class="headerlink" title="应用场景-最短路径问题"></a>应用场景-最短路径问题</h2><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/pulimu1.jpg" alt="弗洛伊德算法"></p><ol><li>胜利乡有7 个村庄(A, B, C, D, E, F, G)</li><li>各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里</li><li>问：如何计算出各村庄到其它各村庄的最短距离?</li></ol><h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="comment">//创建邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//创建Graph 对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex.length, matrix, vertex);</span><br><span class="line">        <span class="comment">//调用弗洛伊德算法</span></span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放顶点的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存到达目标顶点的前驱顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] matrix, <span class="keyword">char</span>[] vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis = matrix;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="comment">// 对pre 数组初始化, 注意存放的是前驱顶点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示pre 数组和dis 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了显示便于阅读，我们优化一下输出</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 先将pre 数组输出的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// 输出dis 数组的一行数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">"("</span> + vertex[k] + <span class="string">"到"</span> + vertex[i] + <span class="string">"的最短路径是"</span> + dis[k][i] + <span class="string">") "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//变量保存距离</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对中间顶点遍历， k 就是中间顶点的下标[A, B, C, D, E, F, G]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">//从i 顶点开始出发[A, B, C, D, E, F, G]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                <span class="comment">//到达j 顶点// [A, B, C, D, E, F, G]</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    <span class="comment">// =&gt; 求出从i 顶点出发，经过k 中间顶点，到达j 顶点距离</span></span><br><span class="line">                    len = dis[i][k] + dis[k][j];</span><br><span class="line">                    <span class="comment">//如果len 小于dis[i][j]</span></span><br><span class="line">                    <span class="keyword">if</span> (len &lt; dis[i][j]) &#123;</span><br><span class="line">                        <span class="comment">//更新距离</span></span><br><span class="line">                        dis[i][j] = len;</span><br><span class="line">                        <span class="comment">//更新前驱顶点</span></span><br><span class="line">                        pre[i][j] = pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="马踏棋盘算法"><a href="#马踏棋盘算法" class="headerlink" title="马踏棋盘算法"></a>马踏棋盘算法</h1><h2 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><p>马踏棋盘算法也被称为骑士周游问题。</p></li><li><p>将马随机放在国际象棋的8×8 棋盘Board[0<del>7][0</del>7]的某个方格中，马按走棋规则(<strong>马走日字</strong>)进行移动。要求每个方格只进入一次，走遍棋盘上全部64 个方格。</p></li><li><p>游戏演示: <a href="http://www.4399.com/flash/146267_2.htm" rel="external nofollow noopener noreferrer" target="_blank">http://www.4399.com/flash/146267_2.htm</a></p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/qipan1.jpg" alt="马踏棋盘算法"></p></li></ul><h2 id="思路分析-7"><a href="#思路分析-7" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li>马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。</li><li>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53 个点，如图：走到了第53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯……</li></ul><p>对第一种实现方式的思路图解：</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/qipan2.jpg" alt="马踏棋盘算法"></p><p>分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题。</p><p><img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/2019-07/algorithmAndDataStructure/qipan3.jpg" alt="马踏棋盘算法"></p><h2 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseChessboard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 棋盘的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 棋盘的列数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个属性，标记是否棋盘的所有位置都被访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"骑士周游算法，开始运行~~"</span>);</span><br><span class="line">        X = <span class="number">8</span>;</span><br><span class="line">        Y = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">//马儿初始位置的行，从1 开始编号</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//马儿初始位置的列，从1 开始编号</span></span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X * Y];</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard, row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"共耗时: "</span> + (end - start) + <span class="string">" 毫秒"</span>);</span><br><span class="line">        <span class="comment">//输出棋盘的最后情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessboard) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> step : rows) &#123;</span><br><span class="line">                System.out.print(step + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成骑士周游问题的算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessboard 棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row        马儿当前的位置的行从0 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column     马儿当前的位置的列从0 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step       是第几步,初始位置就是第1 步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversalChessboard</span><span class="params">(<span class="keyword">int</span>[][] chessboard, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        chessboard[row][column] = step;</span><br><span class="line">        <span class="comment">//row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36</span></span><br><span class="line">        <span class="comment">//标记该位置已经访问</span></span><br><span class="line">        visited[row * X + column] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//获取当前位置可以走的下一个位置的集合</span></span><br><span class="line">        ArrayList&lt;Point&gt; ps = next(<span class="keyword">new</span> Point(column, row));</span><br><span class="line">        <span class="comment">//对ps 进行排序,排序的规则就是对ps 的所有的Point 对象的下一步的位置的数目，进行非递减排序</span></span><br><span class="line">        sort(ps);</span><br><span class="line">        <span class="comment">//遍历ps</span></span><br><span class="line">        <span class="keyword">while</span> (!ps.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出下一个可以走的位置</span></span><br><span class="line">            Point p = ps.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断该点是否已经访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[p.y * X + p.x]) &#123;</span><br><span class="line">                <span class="comment">//说明还没有访问过</span></span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿是否完成了任务，使用step 和应该走的步数比较，</span></span><br><span class="line">        <span class="comment">//如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span></span><br><span class="line">        <span class="comment">//说明: step &lt; X * Y 成立的情况有两种</span></span><br><span class="line">        <span class="comment">//1. 棋盘到目前位置,仍然没有走完</span></span><br><span class="line">        <span class="comment">//2. 棋盘处于一个回溯过程</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; X * Y &amp;&amp; !finished) &#123;</span><br><span class="line">            chessboard[row][column] = <span class="number">0</span>;</span><br><span class="line">            visited[row * X + column] = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">next</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Point&gt; ps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个Point</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">        <span class="comment">//表示马儿可以走5 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走6 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走7 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走0 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走1 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走2 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走3 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走4 这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(ArrayList&lt;Point&gt; ps)</span> </span>&#123;</span><br><span class="line">        ps.sort(Comparator.comparingInt(o -&gt; next(o).size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div><div><div id="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';"> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/static/wechat_pay.jpg" alt="kangjinghang 微信支付"><p>微信支付</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> kangjinghang</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://lijingyuan.top/重学Java数据结构和算法（常用算法）.html" title="重学Java数据结构和算法（常用算法）">https://lijingyuan.top/重学Java数据结构和算法（常用算法）.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/算法/" rel="tag"># 算法</a> <a href="/tags/二分查找算法/" rel="tag"># 二分查找算法</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/重学Java数据结构和算法（递归）.html" rel="next" title="重学Java数据结构和算法（递归）"><i class="fa fa-chevron-left"></i> 重学Java数据结构和算法（递归）</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></div></article></div></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5351135917838281" data-ad-slot="5827056535" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://blog-1259650185.cos.ap-beijing.myqcloud.com/blog/static/headImg-li.jpg" alt="kangjinghang"><p class="site-author-name" itemprop="name">kangjinghang</p><div class="site-description motion-element" itemprop="description">不安便求安，安之又思变。</div></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=441442&auto=0&height=66"></iframe><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kangjinghang" title="GitHub &rarr; https://github.com/kangjinghang" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:kangjinghang@gmail.com" title="E-Mail &rarr; mailto:kangjinghang@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/60aa1a125369" title="简书 &rarr; https://www.jianshu.com/u/60aa1a125369" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/kangjnghang" title="CSDN &rarr; https://blog.csdn.net/kangjnghang" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-spinner"></i> CSDN</a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找算法"><span class="nav-number">1.</span> <span class="nav-text">二分查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍"><span class="nav-number">1.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现"><span class="nav-number">1.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分治算法"><span class="nav-number">2.</span> <span class="nav-text">分治算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-1"><span class="nav-number">2.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本步骤"><span class="nav-number">2.2.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式"><span class="nav-number">2.3.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-汉诺塔"><span class="nav-number">2.4.</span> <span class="nav-text">应用场景-汉诺塔</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路分析"><span class="nav-number">2.4.1.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划算法"><span class="nav-number">3.</span> <span class="nav-text">动态规划算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-2"><span class="nav-number">3.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-背包问题"><span class="nav-number">3.2.</span> <span class="nav-text">应用场景-背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路分析-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">思路分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KMP-算法"><span class="nav-number">4.</span> <span class="nav-text">KMP 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景"><span class="nav-number">4.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#暴力匹配算法"><span class="nav-number">4.2.</span> <span class="nav-text">暴力匹配算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-3"><span class="nav-number">4.3.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路分析-2"><span class="nav-number">4.4.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-2"><span class="nav-number">4.5.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#贪心算法"><span class="nav-number">5.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-4"><span class="nav-number">5.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-集合覆盖"><span class="nav-number">5.2.</span> <span class="nav-text">应用场景-集合覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路分析-3"><span class="nav-number">5.3.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-3"><span class="nav-number">5.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">5.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#普里姆算法"><span class="nav-number">6.</span> <span class="nav-text">普里姆算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-修路问题"><span class="nav-number">6.1.</span> <span class="nav-text">应用场景-修路问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树"><span class="nav-number">6.2.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-5"><span class="nav-number">6.3.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-4"><span class="nav-number">6.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#克鲁斯卡尔算法"><span class="nav-number">7.</span> <span class="nav-text">克鲁斯卡尔算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-公交站问题"><span class="nav-number">7.1.</span> <span class="nav-text">应用场景-公交站问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-6"><span class="nav-number">7.2.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路分析-4"><span class="nav-number">7.3.</span> <span class="nav-text">思路分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图解说明"><span class="nav-number">7.3.1.</span> <span class="nav-text">图解说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析"><span class="nav-number">7.3.2.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回路问题"><span class="nav-number">7.3.3.</span> <span class="nav-text">回路问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-5"><span class="nav-number">7.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迪杰斯特拉算法"><span class="nav-number">8.</span> <span class="nav-text">迪杰斯特拉算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-最短路径问题"><span class="nav-number">8.1.</span> <span class="nav-text">应用场景-最短路径问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-7"><span class="nav-number">8.2.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路分析-5"><span class="nav-number">8.3.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-6"><span class="nav-number">8.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#弗洛伊德算法"><span class="nav-number">9.</span> <span class="nav-text">弗洛伊德算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-8"><span class="nav-number">9.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路分析-6"><span class="nav-number">9.2.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景-最短路径问题-1"><span class="nav-number">9.3.</span> <span class="nav-text">应用场景-最短路径问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-7"><span class="nav-number">9.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#马踏棋盘算法"><span class="nav-number">10.</span> <span class="nav-text">马踏棋盘算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-9"><span class="nav-number">10.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路分析-7"><span class="nav-number">10.2.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-8"><span class="nav-number">10.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas" style=""><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AVL树/">AVL树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-树/">B*树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-树/">B+树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B树/">B树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人网站/">个人网站</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分查找算法/">二分查找算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉排序树/">二叉排序树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/冒泡排序/">冒泡排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈希表/">哈希表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图/">图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆排序/">堆排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多路查找树/">多路查找树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/希尔排序/">希尔排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平衡二叉树/">平衡二叉树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/广度优先遍历/">广度优先遍历</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归并排序/">归并排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速排序/">快速排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插值查找算法/">插值查找算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插入排序/">插入排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/斐波那契查找算法/">斐波那契查找算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找算法/">查找算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度优先遍历/">深度优先遍历</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稀疏数组/">稀疏数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线索化二叉树/">线索化二叉树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/赫夫曼树/">赫夫曼树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/赫夫曼编码/">赫夫曼编码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆波兰计算器/">逆波兰计算器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择排序/">选择排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归算法/">递归算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/零基础/">零基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/顺序二叉树/">顺序二叉树</a><span class="tag-list-count">1</span></li></ul></canvas></div></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5351135917838281" data-ad-slot="5827056535" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><a href="http://www.beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank"></a> &copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="animate"><i class="fa fa-kangjinghang"></i></span> <span class="author" itemprop="copyrightHolder">康璟杭</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">227k</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.2.0"></script><script src="/js/motion.js?v=7.2.0"></script><script src="/js/affix.js?v=7.2.0"></script><script src="/js/schemes/pisces.js?v=7.2.0"></script><script src="/js/scrollspy.js?v=7.2.0"></script><script src="/js/post-details.js?v=7.2.0"></script><script src="/js/next-boot.js?v=7.2.0"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(i){return-1<GUEST.indexOf(i)}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"qtqNa1EO4zgiWv0gFi2iEKnx-gzGzoHsz",appKey:"GzN0JNY6Tp7fAM4NzOBlti8v",placeholder:"欢迎交流讨论...",avatar:"mm",meta:guest,pageSize:"10",visitor:!1,lang:"zh-cn"})</script><script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,Douban,QQZone"},new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={iconStyle:"box",boxForm:"horizontal",position:"middleRight",networks:"Weibo,Wechat,Douban,QQZone"},new needShareButton("#needsharebutton-float",flOptions)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/haruto.model.json"},display:{position:"right",width:100,height:310},mobile:{show:!1},react:{opacity:.7},log:!1})</script></body></html>