<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（树结构基础）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%91%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉树为什么需要树这种数据结构数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低。 操作示意图： 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 。 操作示意图： 树存储方式的分析能提高数据存储，读取的效率, 比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。 案例: [7, 3, 10, 1, 5, 9, 12] 树示意图 树的常用术语(结合示意图理解): 节点 根节点 父节点 子节点 叶子节点(没有子节点的节点) 节点的权(节点值) 路径(从root 节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林:多颗子树构成森林 二叉树的概念 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 二叉树的子节点分为左节点和右节点。 示意图： 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。 遍历节点可使用前序，中序和后序对下面的二叉树进行遍历。 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 小结: 看输出父节点的顺序，就确定是前序，中序还是后序 遍历节点应用实例(前序,中序,后序)应用实例的说明和思路 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, "宋江"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 System.out.println("前序遍历"); // 1,2,3,5,4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2,1,5,3,4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2,5,4,3,1 binaryTree.postOrder(); &#125;&#125;/** * 二叉树 */class BinaryTree &#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; /** * 前序遍历 */ public void preOrder() &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; if (root != null) &#123; root.postOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125;&#125;class HeroNode &#123; private int no; private String name; /** * 默认null */ private HeroNode left; /** * 默认null */ private HeroNode right; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return "HeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125; /** * 前序遍历 */ public void preOrder() &#123; // 输出父结点 System.out.println(this); // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; // 输出父结点 System.out.println(this); // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.postOrder(); &#125; // 输出父结点 System.out.println(this); &#125;&#125; 查找指定节点要求： 请编写前序查找，中序查找和后序查找的方法。 并分别使用三种查找方式，查找heroNo = 5 的节点 并分析各种查找方式，分别比较了多少次 思路分析图解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, "宋江"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 System.out.println("前序遍历"); // 1,2,3,5,4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2,1,5,3,4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2,5,4,3,1 binaryTree.postOrder(); System.out.println(); System.out.println("--------------------------"); int no = 5; // 前序遍历 // 前序遍历的次数：4 System.out.println("前序遍历方式~~~"); HeroNode resNode = binaryTree.preOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); // 中序遍历查找 // 中序遍历3 次 System.out.println("中序遍历方式~~~"); resNode = binaryTree.infixOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); //后序遍历查找 //后序遍历查找的次数2 次 System.out.println("后序遍历方式~~~"); resNode = binaryTree.postOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; &#125;&#125;/** * 二叉树增加方法，其他代码同上，省略 */class BinaryTree &#123; /** * 前序查找 */ public HeroNode preOrderSearch(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; /** * 中序查找 */ public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; /** * 后序查找 */ public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;/** * HeroNode增加方法，其他代码同上，省略 */class HeroNode &#123; /** * 前序遍历查找 * * @param no no */ public HeroNode preOrderSearch(int no) &#123; System.out.println("进入前序遍历"); // 比较当前结点是不是 if (this.no == no) &#123; return this; &#125; // 1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找 // 2.如果左递归前序查找，找到结点，则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; // 说明我们左子树找到 if (resNode != null) &#123; return resNode; &#125; // 1.左递归前序查找，找到结点，则返回，否继续判断 // 2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; /** * 中序遍历查找 * * @param no no */ public HeroNode infixOrderSearch(int no) &#123; // 判断当前结点的左子节点是否为空，如果不为空，则递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println("进入中序遍历"); // 如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点 if (this.no == no) &#123; return this; &#125; // 否则继续进行右递归的中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; /** * 后序遍历查找 * * @param no no */ public HeroNode postOrderSearch(int no) &#123; // 判断当前结点的左子节点是否为空，如果不为空，则递归后序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; // 说明在左子树找到 return resNode; &#125; // 如果左子树没有找到，则向右子树递归进行后序遍历查找 if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println("进入后序查找"); // 如果左右子树都没有找到，就比较当前结点是不是 if (this.no == no) &#123; return this; &#125; return null; &#125;&#125; 删除节点要求： 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树 测试，删除掉5 号叶子节点和3 号子树 思路分析图解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, "宋江"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 System.out.println("前序遍历"); // 1,2,3,5,4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2,1,5,3,4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2,5,4,3,1 binaryTree.postOrder(); System.out.println(); System.out.println("--------------------------"); int no = 5; // 前序遍历 // 前序遍历的次数：4 System.out.println("前序遍历方式~~~"); HeroNode resNode = binaryTree.preOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); // 中序遍历查找 // 中序遍历3 次 System.out.println("中序遍历方式~~~"); resNode = binaryTree.infixOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); //后序遍历查找 //后序遍历查找的次数2 次 System.out.println("后序遍历方式~~~"); resNode = binaryTree.postOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); //测试一把删除结点 System.out.println("删除前,前序遍历"); binaryTree.preOrder(); // 1,2,3,5,4 binaryTree.delNode(5); binaryTree.delNode(3); System.out.println("删除后，前序遍历"); binaryTree.preOrder(); // 1,2,3,4 &#125;&#125;/** * 二叉树增加方法，其他代码同上，省略 */class BinaryTree &#123; /** * 删除节点 * * @param no no */ public void delNode(int no) &#123; if (root != null) &#123; // 如果只有一个root 结点, 这里立即判断root 是不是就是要删除结点 if (root.getNo() == no) &#123; root = null; &#125; else &#123; // 递归删除 root.delNode(no); &#125; &#125; else &#123; System.out.println("空树，不能删除~"); &#125; &#125;&#125;/** * HeroNode增加方法，其他代码同上，省略 */class HeroNode &#123; /** * 递归删除结点 * 1.如果删除的节点是叶子节点，则删除该节点 * 2.如果删除的节点是非叶子节点，则删除该子树 * * @param no no */ public void delNode(int no) &#123; /* * 思路 * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. * 2. 如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) * 3. 如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this.right= null; 并且就返回(结束递归删除) * 4. 如果第2步和第3步没有删除结点，那么我们就需要向左子树进行递归删除 * 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. */ // 2.如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; // 3. 如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this.right= null; 并且就返回(结束递归删除) if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; // 4.我们就需要向左子树进行递归删除 if (this.left != null) &#123; this.left.delNode(no); &#125; // 5.则应当向右子树进行递归删除 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125;&#125; 顺序存储二叉树顺序存储二叉树的概念基本说明从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看右面的示意图。 顺序存储二叉树的特点 顺序二叉树通常只考虑完全二叉树 第 n 个元素的左子节点为2 * n + 1 第 n 个元素的右子节点为2 * n + 2 第 n 个元素的父节点为(n-1) / 2 n : 表示二叉树中的第几个元素(按0 开始编号如图所示) 顺序存储二叉树遍历需求: 给定一个数组{1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。前序遍历的结果应当为1,2,4,5,3,6,7。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ArrBinaryTreeDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;; // 创建一个ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); // 1,2,4,5,3,6,7 arrBinaryTree.preOrder(); &#125;&#125;/** * 编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历 */class ArrBinaryTree &#123; /** * 存储数据结点的数组 */ private int[] arr; public ArrBinaryTree(int[] arr) &#123; this.arr = arr; &#125; /** * 重载preOrder */ public void preOrder() &#123; this.preOrder(0); &#125; /** * 编写一个方法，完成顺序存储二叉树的前序遍历 * * @param index 数组的下标 */ public void preOrder(int index) &#123; // 如果数组为空，或者arr.length = 0 if (arr == null || arr.length == 0) &#123; System.out.println("数组为空，不能按照二叉树的前序遍历"); &#125; // 输出当前这个元素 System.out.println(arr[index]); // 向左递归遍历 int leftIndex = index * 2 + 1; if (leftIndex &lt; arr.length) &#123; preOrder(leftIndex); &#125; // 向右递归遍历 int rightIndex = index * 2 + 2; if (rightIndex &lt; arr.length) &#123; preOrder(rightIndex); &#125; &#125;&#125; 线索化二叉树问题分析将数列{1, 3, 6, 8, 10, 14 } 构建成一颗二叉树。n+1=7 当我们对上面的二叉树进行中序遍历时，数列为{8, 3, 10, 1, 6, 14 } 但是6, 8, 10, 14 这几个节点的左右指针，并没有完全的利用上 如果我们希望充分的利用各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 解决方案-线索二叉树 基本介绍 n 个结点的二叉链表中含有n+1 【公式2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(ThreadedBinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 线索化二叉树要求：将下面的二叉树，线索化为中序线索二叉树。中序遍历的数列为{8, 3, 10, 1, 14, 6}。思路：中序遍历的结果：{8, 3, 10, 1, 14, 6}。 说明：当线索化二叉树后，Node 节点的属性left 和right ，有如下情况： left 指向的是左子树，也可能是指向的前驱节点。 比如① 节点left 指向的左子树, 而⑩ 节点的left 指向的就是前驱节点。 right 指向的是右子树，也可能是指向后继节点。比如① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点。 代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183public class ThreadedBinaryTreeDemo &#123; public static void main(String[] args) &#123; // 测试一把中序线索二叉树的功能 ThreadedHeroNode root = new ThreadedHeroNode(1, "tom"); ThreadedHeroNode node2 = new ThreadedHeroNode(3, "jack"); ThreadedHeroNode node3 = new ThreadedHeroNode(6, "smith"); ThreadedHeroNode node4 = new ThreadedHeroNode(8, "mary"); ThreadedHeroNode node5 = new ThreadedHeroNode(10, "king"); ThreadedHeroNode node6 = new ThreadedHeroNode(14, "dim"); // 二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); // 测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); // 测试: 以10 号节点测试 ThreadedHeroNode leftNode = node5.getLeft(); ThreadedHeroNode rightNode = node5.getRight(); // 3 System.out.println("10 号结点的前驱结点是=" + leftNode); // 1 System.out.println("10 号结点的后继结点是=" + rightNode); &#125;&#125;/** * 线索化二叉树, 实现了线索化功能的二叉树 */class ThreadedBinaryTree &#123; private ThreadedHeroNode root; /** * 当前线索化二叉树线索化过的最后一个节点 * &lt;/p&gt; * 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 * 在递归进行线索化时，pre 总是保留前一个结点 */ private ThreadedHeroNode pre = null; public void setRoot(ThreadedHeroNode root) &#123; this.root = root; &#125; public void threadedNodes() &#123; this.threadedNodes(root); &#125; /** * 二叉树进行中序线索化的方法 * * @param node 当前需要线索化的结点 */ public void threadedNodes(ThreadedHeroNode node) &#123; // 如果node==null, 不能线索化 if (node == null) &#123; return; &#125; // (一)先线索化左子树 threadedNodes(node.getLeft()); // (二)线索化当前结点 // 处理当前结点的前驱结点 // 以 8 结点来理解 // 8 结点的.left = null , 8 结点的.leftType = 1 if (node.getLeft() == null) &#123; // 让当前结点的左指针指向前驱结点 node.setLeft(pre); node.setLeftType(1); &#125; // 处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让树的前驱结点的右指针指向当前结点 pre.setRight(node); // 修改树的前驱结点的右指针类型 pre.setRightType(1); &#125; // !!! 每处理一个结点后，将当前结点设置为这棵树的前驱结点 pre = node; // (三)再线索化右子树 threadedNodes(node.getRight()); &#125;&#125;class ThreadedHeroNode &#123; private int no; private String name; /** * 默认null */ private ThreadedHeroNode left; /** * 默认null */ private ThreadedHeroNode right; /** * 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 */ private int leftType; /** * 如果rightType == 0 表示指向是右子树, 如果 1 则表示指向后继结点 */ private int rightType; public ThreadedHeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ThreadedHeroNode getLeft() &#123; return left; &#125; public void setLeft(ThreadedHeroNode left) &#123; this.left = left; &#125; public ThreadedHeroNode getRight() &#123; return right; &#125; public void setRight(ThreadedHeroNode right) &#123; this.right = right; &#125; public int getLeftType() &#123; return leftType; &#125; public void setLeftType(int leftType) &#123; this.leftType = leftType; &#125; public int getRightType() &#123; return rightType; &#125; public void setRightType(int rightType) &#123; this.rightType = rightType; &#125; @Override public String toString() &#123; return "ThreadedHeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125;&#125; 遍历线索化二叉树要求：对前面的中序线索化的二叉树， 进行遍历。 思路：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213public class ThreadedBinaryTreeDemo &#123; public static void main(String[] args) &#123; // 测试一把中序线索二叉树的功能 ThreadedHeroNode root = new ThreadedHeroNode(1, "tom"); ThreadedHeroNode node2 = new ThreadedHeroNode(3, "jack"); ThreadedHeroNode node3 = new ThreadedHeroNode(6, "smith"); ThreadedHeroNode node4 = new ThreadedHeroNode(8, "mary"); ThreadedHeroNode node5 = new ThreadedHeroNode(10, "king"); ThreadedHeroNode node6 = new ThreadedHeroNode(14, "dim"); // 二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); // 测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); // 测试: 以10 号节点测试 ThreadedHeroNode leftNode = node5.getLeft(); ThreadedHeroNode rightNode = node5.getRight(); // 3 System.out.println("10 号结点的前驱结点是=" + leftNode); // 1 System.out.println("10 号结点的后继结点是=" + rightNode); System.out.println("使用线索化的方式遍历线索化二叉树"); // 8, 3, 10, 1, 14, 6 threadedBinaryTree.threadedList(); &#125;&#125;/** * 线索化二叉树, 实现了线索化功能的二叉树 */class ThreadedBinaryTree &#123; private ThreadedHeroNode root; /** * 当前线索化二叉树线索化过的最后一个节点 * &lt;/p&gt; * 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 * 在递归进行线索化时，pre 总是保留前一个结点 */ private ThreadedHeroNode pre = null; public void setRoot(ThreadedHeroNode root) &#123; this.root = root; &#125; public void threadedNodes() &#123; this.threadedNodes(root); &#125; /** * 二叉树进行中序线索化的方法 * * @param node 当前需要线索化的结点 */ public void threadedNodes(ThreadedHeroNode node) &#123; // 如果node==null, 不能线索化 if (node == null) &#123; return; &#125; // (一)先线索化左子树 threadedNodes(node.getLeft()); // (二)线索化当前结点 // 处理当前结点的前驱结点 // 以 8 结点来理解 // 8 结点的.left = null , 8 结点的.leftType = 1 if (node.getLeft() == null) &#123; // 让当前结点的左指针指向前驱结点 node.setLeft(pre); node.setLeftType(1); &#125; // 处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让树的前驱结点的右指针指向当前结点 pre.setRight(node); // 修改树的前驱结点的右指针类型 pre.setRightType(1); &#125; // !!! 每处理一个结点后，将当前结点设置为这棵树的前驱结点 pre = node; // (三)再线索化右子树 threadedNodes(node.getRight()); &#125; /** * 遍历线索化二叉树的方法 */ public void threadedList() &#123; // 定义一个变量，存储当前遍历的结点，从 root 开始 ThreadedHeroNode node = root; while(node != null)&#123; // 循环的找到 leftType == 1 的结点，第一个找到就是 8 结点 // 后面随着遍历而变化,因为当 leftType==1 时，说明该结点是按照线索化处理后的有效结点 while(node.getLeftType() == 0)&#123; node = node.getLeft(); &#125; // 打印当前这个结点 System.out.println(node); // 如果当前结点的右指针指向的是后继结点,就一直输出 while(node.getRightType() == 1) &#123; // 获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); &#125; // 替换这个遍历的结点 node = node.getRight(); &#125; &#125;&#125;class ThreadedHeroNode &#123; private int no; private String name; /** * 默认null */ private ThreadedHeroNode left; /** * 默认null */ private ThreadedHeroNode right; /** * 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 */ private int leftType; /** * 如果rightType == 0 表示指向是右子树, 如果 1 则表示指向后继结点 */ private int rightType; public ThreadedHeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ThreadedHeroNode getLeft() &#123; return left; &#125; public void setLeft(ThreadedHeroNode left) &#123; this.left = left; &#125; public ThreadedHeroNode getRight() &#123; return right; &#125; public void setRight(ThreadedHeroNode right) &#123; this.right = right; &#125; public int getLeftType() &#123; return leftType; &#125; public void setLeftType(int leftType) &#123; this.leftType = leftType; &#125; public int getRightType() &#123; return rightType; &#125; public void setRightType(int rightType) &#123; this.rightType = rightType; &#125; @Override public String toString() &#123; return "ThreadedHeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>顺序二叉树</tag>
        <tag>线索化二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（查找算法）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[查找算法介绍在java 中，我们常用的查找有四种: 顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找 线性查找算法有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】要求: 如果找到了，就提示找到，并给出下标值。 代码实现123456789101112131415161718192021222324252627public class SeqSearch &#123; public static void main(String[] args) &#123; // 没有顺序的数组 int arr[] = &#123;1, 9, 11, -1, 34, 89&#125;; int index = seqSearch(arr, 89); if (index == -1) &#123; System.out.println("没有找到"); &#125; else &#123; System.out.println("找到，下标为=" + index); &#125; &#125; /** * 这里我们实现的线性查找是找到一个满足条件的值，就返回 */ public static int seqSearch(int[] arr, int value) &#123; // 线性查找是逐一比对，发现有相同值，就返回下标 for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == value) &#123; return i; &#125; &#125; return -1; &#125;&#125; 二分查找算法请对一个有序数组进行二分查找{1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 思路分析 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BinarySearch &#123; // 注意：使用二分查找的前提是该数组是有序的。 public static void main(String[] args) &#123; int arr[] = &#123;1, 8, 10, 89, 1000, 1000, 1234&#125;; int resIndex = binarySearch(arr, 0, arr.length - 1, 1234); System.out.println("resIndex=" + resIndex); List&lt;Integer&gt; list = binarySearch2(arr, 0, arr.length - 1, 1000); System.out.println("resIndex=" + list); &#125; /** * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回-1 */ public static int binarySearch(int[] arr, int left, int right, int findVal) &#123; // 当left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向右递归 return binarySearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125; /** * 思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000 * &lt;p&gt; * 思路分析 * 1. 在找到mid 索引值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList * 4. 将Arraylist 返回 */ public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123; // 当left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return new ArrayList&lt;&gt;(); &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向右递归 return binarySearch2(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch2(arr, left, mid - 1, findVal); &#125; else &#123; List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;(); // 向mid 索引值的左边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList int temp = mid - 1; while (true) &#123; // 退出 if (temp &lt; 0 || arr[temp] != findVal) &#123; break; &#125; // 否则，就temp 放入到resIndexlist resIndexlist.add(temp); // temp 左移 temp--; &#125; resIndexlist.add(mid); // 向mid 索引值的右边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList temp = mid + 1; while (true) &#123; // 退出 if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123; break; &#125; // 否则，就temp 放入到resIndexlist resIndexlist.add(temp); // temp 右移 temp++; &#125; return resIndexlist; &#125; &#125;&#125; 插值查找算法基本介绍插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid 处开始查找。 基本原理 将折半查找中的求mid 索引的公式, low 表示左边索引left, high 表示右边索引right。 key 就是前面我们讲的findVal int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ; //插值索引 对应前面的代码公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 思路分析 代码实现请对一个有序数组进行插值查找{1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 123456789101112131415161718192021222324252627282930313233343536public class InsertValueSearch &#123; public static void main(String[] args) &#123; int arr[] = &#123;1, 8, 10, 89, 1000, 1000, 1234&#125;; int index = insertValueSearch(arr, 0, arr.length - 1, 89); System.out.println("index = " + index); &#125; /** * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回-1 */ public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; // 注意：findVal &lt; arr[0] 和findVal &gt; arr[arr.length - 1] 必须需要 // 否则我们得到的mid 可能越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123; return -1; &#125; // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; // 说明应该向右边递归 if (findVal &gt; midVal) &#123; return insertValueSearch(arr, mid + 1, right, findVal); // 说明向左递归查找 &#125; else if (findVal &lt; midVal) &#123; return insertValueSearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125;&#125; 注意事项 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。 关键字分布不均匀的情况下，该方法不一定比折半查找要好。 斐波那契(黄金分割法)查找算法基本介绍 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意想不到的效果。 斐波那契数列{1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618。 基本原理斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示 对F(k-1)-1 的理解： 由斐波那契数列F[k]=F[k-1]+F[k-2] 的性质，可以得到（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1 和F[k-2]-1 的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1。 类似的，每一子段也可以用相同的方式分割。 但顺序表长度n 不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n 增加至F[k]-1。这里的k 值只要能使得F[k]-1 恰好大于或等于n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1 到F[k]-1 位置），都赋为n 位置的值即可。 123while(n &gt; fib(k)-1)&#123; k++; &#125; 代码实现请对一个有序数组进行斐波那契查找{1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class FibonacciSearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 8, 10, 89, 1000, 1234&#125;; System.out.println("index=" + fibSearch(arr, 89)); &#125; public static int maxSize = 20; /** * 因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 * 非递归方法得到一个斐波那契数列 */ public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; /** * @param a 数组 * @param key 我们需要查找的关键码(值) * @return 返回对应的下标，如果没有-1 */ public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; //表示斐波那契分割数值的下标 int k = 0; // 存放mid 值 int mid = 0; // 获取到斐波那契数列 int[] f = fib(); // 获取到斐波那契分割数值的下标 while (high &gt; f[k] - 1) &#123; k++; &#125; //因为f[k] 值可能大于a 的长度，因此我们需要使用Arrays 类，构造一个新的数组，并指向temp[] //不足的部分会使用0 填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a 数组最后的数填充temp //举例: //temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125; for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; // 使用while 来循环处理，找到我们的数key // 只要这个条件满足，就可以找 while (low &lt;= high) &#123; mid = low + f[k - 1] - 1; // 我们应该继续向数组的前面查找(左边) if (key &lt; temp[mid]) &#123; high = mid - 1; // 为什么是k-- // 说明 // 1. 全部元素= 前面的元素+ 后边元素 // 2. f[k] = f[k-1] + f[k-2] // 因为前面有f[k-1]个元素,所以可以继续拆分f[k-1] = f[k-2] + f[k-3] // 即在f[k-1] 的前面继续查找k-- // 即下次循环mid = f[k-1-1]-1 k--; &#125; else if (key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边) low = mid + 1; // 为什么是k -=2 // 说明 // 1. 全部元素= 前面的元素+ 后边元素 // 2. f[k] = f[k-1] + f[k-2] // 3. 因为后面我们有f[k-2] 所以可以继续拆分f[k-2] = f[k-3] + f[k-4] // 4. 即在f[k-2] 的前面进行查找k -=2 // 5. 即下次循环mid = f[k - 1 - 2] - 1 k -= 2; &#125; else &#123; //找到 // 需要确定，返回的是哪个下标 if (mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>查找算法</tag>
        <tag>二分查找算法</tag>
        <tag>插值查找算法</tag>
        <tag>斐波那契查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（哈希表）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本介绍散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 google上机题目有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id 时,要求查找到该员工的所有信息.要求: 不使用数据库,,速度越快越好=&gt;哈希表(散列) 添加时，保证按照id 从低到高插入[课后思考：如果id 不是从低到高插入，但要求各条链表仍是从低到高，怎么解决? 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] 思路分析并画出示意图 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public class HashTabDemo &#123; public static void main(String[] args) &#123; //创建哈希表 HashTab hashTab = new HashTab(7); //写一个简单的菜单 String key = ""; Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.println("add: 添加雇员"); System.out.println("list: 显示雇员"); System.out.println("find: 查找雇员"); System.out.println("exit: 退出系统"); key = scanner.next(); switch (key) &#123; case "add": System.out.println("输入id"); int id = scanner.nextInt(); System.out.println("输入名字"); String name = scanner.next(); //创建雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case "list": hashTab.list(); break; case "find": System.out.println("请输入要查找的id"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case "exit": scanner.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;/** * 创建HashTab 管理多条链表 */class HashTab &#123; private EmpLinkedList[] empLinkedListArray; private int size; /** * 构造器 * * @param size size */ public HashTab(int size) &#123; this.size = size; // 初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; /** * 添加雇员 * * @param emp emp */ public void add(Emp emp) &#123; //根据员工的id ,得到该员工应当添加到哪条链表 int empLinkedListNo = hashFun(emp.id); //将emp 添加到对应的链表中 empLinkedListArray[empLinkedListNo].add(emp); &#125; /** * 遍历所有的链表,遍历hashtab */ public void list() &#123; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i].list(i); &#125; &#125; /** * 根据输入的id,查找雇员 * * @param id id */ public void findEmpById(int id) &#123; // 使用散列函数确定到哪条链表查找 int empLinkedListNo = hashFun(id); Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id); if (emp != null) &#123; // 找到 System.out.printf("在第%d条链表中找到雇员id = %d\n", (empLinkedListNo + 1), id); &#125; else &#123; System.out.println("在哈希表中，没有找到该雇员~"); &#125; &#125; /** * 编写散列函数, 使用一个简单取模法 */ public int hashFun(int id) &#123; return id % size; &#125;&#125;class Emp &#123; public int id; public String name; /** * next 默认为null */ public Emp next; public Emp(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125;/** * 创建EmpLinkedList ,表示链表 */class EmpLinkedList &#123; /** * 头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp * 默认null */ private Emp head; /** * 添加雇员到链表 * 说明 * 1. 假定，当添加雇员时，id 是自增长，即id 的分配总是从小到大 * 因此我们将该雇员直接加入到本链表的最后即可 */ public void add(Emp emp) &#123; if (head == null) &#123; head = emp; return; &#125; // 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp = head; while (true) &#123; if (curEmp.next == null) &#123; // 说明到链表最后 break; &#125; // 后移 curEmp = curEmp.next; &#125; // 退出时直接将emp 加入链表 curEmp.next = emp; &#125; /** * 遍历链表的雇员信息 */ public void list(int no) &#123; if (head == null) &#123; // 说明链表为空 System.out.println("第" + (no + 1) + " 链表为空"); return; &#125; System.out.print("第" + (no + 1) + " 链表的信息为"); // 辅助指针 Emp curEmp = head; while (true) &#123; System.out.printf(" =&gt; id=%d name=%s\t", curEmp.id, curEmp.name); // 说明curEmp 已经是最后结点 if (curEmp.next == null) &#123; break; &#125; // 后移，遍历 curEmp = curEmp.next; &#125; System.out.println(); &#125; /** * 根据id 查找雇员 * 如果查找到，就返回Emp, 如果没有找到，就返回null * * @param id id */ public Emp findEmpById(int id) &#123; //判断链表是否为空 if (head == null) &#123; System.out.println("链表为空"); return null; &#125; //辅助指针 Emp curEmp = head; while (true) &#123; //找到 if (curEmp.id == id) &#123; //这时curEmp 就指向要查找的雇员 break; &#125; //退出 //说明遍历当前链表没有找到该雇员 if (curEmp.next == null) &#123; curEmp = null; break; &#125; //以后 curEmp = curEmp.next; &#125; return curEmp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（排序算法）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排序算法的介绍排序也称排序算法(Sort Algorithm)，排序是将一组数据，依照指定的顺序进行排列的过程。 排序的分类 内部排序法 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 外部排序法 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。 常见的排序算法分类 算法的时间复杂度度量一个程序(算法)执行时间的两种方法 事后统计的方法 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。 事前估算的方法 通过分析某个算法的时间复杂度来判断哪个算法更优。 时间频度 基本介绍一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 举例说明-基本案例比如计算1-100 所有数字之和, 我们设计两种算法： 举例说明-忽略常数项 结论： 2n+20 和2n 随着n 变大，执行曲线无限接近, 20 可以忽略。 3n+10 和3n 随着n 变大，执行曲线无限接近, 10 可以忽略。 举例说明-忽略常数低次项 结论： 2n2+3n+10 和2n2 随着n 变大, 执行曲线无限接近, 可以忽略3n+10。 n2+5n+20 和n2随着n 变大,执行曲线无限接近, 可以忽略5n+20。 举例说明-忽略系数 结论: 随着n 值变大，5n2+7n 和3n2 + 2n ，执行曲线重合, 说明这种情况下, 5 和3 可以忽略。 而n3+5n 和6n3+4n ，执行曲线分离，说明多少次方式关键。 时间复杂度 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n 的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 T(n) 不同，但时间复杂度可能相同。如：T(n)=n2+7n+6 与T(n)=3n2+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n2)。 计算时间复杂度的方法： 用常数1 代替运行时间中的所有加法常数T(n)=n2+7n+6 =&gt; T(n)=n2+7n+1 修改后的运行次数函数中，只保留最高阶项T(n)=n2+7n+1 =&gt; T(n) = n2 去除最高阶项的系数T(n) = n2 =&gt; T(n) = n2 =&gt; O(n2) 常见的时间复杂度 常数阶O(1) 对数阶O(log2n) 线性阶O(n) 线性对数阶O(nlog2n) 平方阶O(n2) 立方阶O(n3) k 次方阶O(nk) 指数阶O(2n) 常见的时间复杂度对应的图： 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 从图中可见，我们应该尽可能避免使用指数阶的算法。 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 。 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n) 说明： 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2) 。 O(log2) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 。 线性阶O(n) 说明： 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 。 线性对数阶O(nlogN) 说明： 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 。 平方阶O(n2) 说明： 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n2)，这段代码其实就是嵌套了2层n循环 ，它的时间复杂度就是 O(n2)，即 O(n2) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n) 。 立方阶O(n3)、K次方阶O(nk)说明： 参考上面的O(n2) 去理解就好了，O(n3)相当于三层n循环，其它的类似。 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图)。 算法的空间复杂度基本介绍 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n 的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n 有关，它随着n 的增大而增大，当n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法， 基数排序就属于这种情况。 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。 冒泡排序基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 思路分析 结论： 一共进行数组的大小-1 次大的循环 每一趟排序的次数在逐渐的减少 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 代码实现对数组[3, 9, -1, 10, -2]进行冒泡排序。 123456789101112131415161718192021public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; // 临时变量 int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag 判断元素是否进行过交换。从而减少不必要的比较。 12345678910111213141516171819202122232425262728293031public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; // 临时变量 int temp = 0; // 标识变量，表示是否进行过交换 boolean flag = false; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); if (!flag) &#123; // 在一趟排序中, 一次交换都没有发生过 break; &#125; else &#123; // 重置flag!!!, 进行下次判断 flag = false; &#125; &#125; &#125;&#125; 选择排序基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。 基本思想选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i 次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1 次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1 次，得到一个按排序码从小到大排列的有序序列。 思路分析 对一个数组的选择排序再进行讲解 代码实现对数组[101, 34, 119, 1]进行选择排序。 12345678910111213141516171819202122232425262728public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 说明假定的最小值，并不是最小 if (min &gt; arr[j]) &#123; // 重置min min = arr[j]; // 重置minIndex minIndex = j; &#125; &#125; // 将最小值，放在arr[i], 即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println("第" + (i + 1) + "轮后~~"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 插入排序基本介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。 基本思想插入排序（Insertion Sorting）的基本思想是：把n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 思路分析 代码实现对数组[101, 34, 119, 1]进行选择排序。 1234567891011121314151617181920212223242526272829303132public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; int insertValue = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) &#123; insertIndex = i - 1; insertValue = arr[i]; // 定义待插入的数 // 说明 // 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]) &#123; // 移位 排序过的元素右移一格 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; // 当退出while 循环时，说明插入的位置找到, insertIndex + 1 // 这里我们判断是否需要赋值 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertValue; &#125; System.out.println("第" + i + "轮插入"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 希尔排序简单插入排序存在的问题我们看简单的插入排序可能存在的问题。数组arr = {2,3,4,5,6,1} 这时需要插入的数1(最小), 这样的过程是： 123456&#123;2,3,4,5,6,6&#125;&#123;2,3,4,5,5,6&#125;&#123;2,3,4,4,5,6&#125;&#123;2,3,3,4,5,6&#125;&#123;2,2,3,4,5,6&#125;&#123;1,2,3,4,5,6&#125; 结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。 基本介绍希尔排序是希尔（Donald Shell）于1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 基本思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1 时，整个文件恰被分成一组，算法便终止。 思路分析 代码实现对数组[8,9,1,7,2,3,5,4,6,0]进行希尔排序。 123456789101112131415161718192021222324252627public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; int count = 0; // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素开始，逐个对每个组来排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j - gap]; j -= gap; &#125; //当退出while 后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; System.out.println("希尔排序第" + (++count) + "轮=" + Arrays.toString(arr)); &#125; &#125;&#125; 快速排序基本介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 思路分析 代码实现对数组[-9,78,0,23,-567,70]进行快速排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class QuickSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;-9, 78, 0, 23, -567, 70&#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; // 左索引 int l = left; // 右索引 int r = right; int pivot = arr[(left + right) / 2]; // 临时变量，作为交换时使用 int temp; // while 循环的目的是让比pivot的值小的放到左边，比pivot值大的放到右边 while (l &lt; r) &#123; // 在pivot的左边一直找,找到大于等于pivot的值,才退出 while (arr[l] &lt; pivot) &#123; l++; &#125; // 在pivot的右边一直找,找到小于等于pivot的值,才退出 while (arr[r] &gt; pivot) &#123; r--; &#125; // 如果l &gt;= r 说明pivot的左右两边的值，已经按照左边全部是小于等于pivot的值，右边全部是大于等于pivot的值 if (l &gt;= r) &#123; break; &#125; //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; // 如果交换完后，发现这个arr[l] == pivot 值相等r--， 前移 if (arr[l] == pivot) &#123; r--; &#125; // 如果交换完后，发现这个arr[r] == pivot 值相等l++， 后移 if (arr[r] == pivot) &#123; l++; &#125; // 如果l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) &#123; l++; r--; &#125; // 向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; // 向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125; &#125;&#125; 归并排序基本介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 基本思想 思路分析再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。 代码实现对数组[8,4,5,7,1,3,6,2]进行归并排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; //归并排序需要一个额外空间 int temp[] = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, temp); System.out.println("归并排序后=" + Arrays.toString(arr)); &#125; //分+合方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; //中间索引 int mid = (left + right) / 2; //向左递归进行分解 mergeSort(arr, left, mid, temp); //向右递归进行分解 mergeSort(arr, mid + 1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; &#125; /** * 合并的方法 * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; // 初始化i, 左边有序序列的初始索引 int i = left; // 初始化j, 右边有序序列的初始索引 int j = mid + 1; // 指向temp 数组的当前索引 int t = 0; // (一) // 先把左右两边(有序)的数据按照规则填充到temp数组 // 直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; // 继续 // 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 // 即将左边的当前元素，填充到temp 数组 // 然后t++, i++ if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t++; i++; &#125; else &#123; // 反之,将右边有序序列的当前元素，填充到temp 数组 temp[t] = arr[j]; t++; j++; &#125; &#125; // (二) // 把有剩余数据的一边的数据依次全部填充到temp while (i &lt;= mid) &#123; // 左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t++; i++; &#125; while (j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t++; j++; &#125; // (三) // 将temp 数组的元素拷贝到arr // 注意，并不是每次都拷贝所有 t = 0; int tempLeft = left; // 第一次合并tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tempLeft=0 right=3 // 最后一次tempLeft = 0 right = 7 while (tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t++; tempLeft++; &#125; &#125;&#125; 基数排序基本介绍 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法。 基数排序(Radix Sort)是桶排序的扩展。 基数排序是1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 思路分析将数组{53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。 代码实现对数组[53, 3, 542, 748, 14, 214]进行基数排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;53, 3, 542, 748, 14, 214&#125;; // 1. 得到数组中最大的数的位数 // 假设第一数就是最大数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; // 得到最大数是几位数 int maxLength = (max + "").length(); // 定义一个二维数组，表示10 个桶, 每个桶就是一个一维数组 // 说明 // 1. 二维数组包含10 个一维数组 // 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length // 3. 明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 // 可以这里理解 // 比如：bucketElementCounts[0] , 记录的就是bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; // 这里我们使用循环将代码处理 for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; // (针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位... for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的对应位的值 int digitOfElement = arr[j] / n % 10; // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k 个桶(即第k 个一维数组), 放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1 轮处理后，需要将每个bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第" + (i + 1) + "轮，排序处理arr =" + Arrays.toString(arr)); &#125; &#125;&#125; 基数排序的说明 基数排序是对传统桶排序的扩展，速度很快。 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成OutOfMemoryError 。 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，请参考这篇文章。 堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为O(nlogn)，它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意: 没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 大顶堆举例说明 小顶堆举例说明 一般升序采用大顶堆，降序采用小顶堆。 基本思想 将待排序序列构造成一个大顶堆。 此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大值。 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了。 思路分析要求：给定一个数组{4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。 步骤一构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组[4, 6, 8, 5, 9] 假设给定无序序列结构如下。 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。 找到第二个非叶节点4，由于[4,9,8]中9 元素最大，4 和 9 交换。 此时，我们就将一个无序序列构造成了一个大顶堆。 步骤二将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 将堆顶元素 9 和末尾元素 4 进行交换。 重新调整结构，使其继续满足堆定义。 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8。 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序。 总结 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HeapSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;4, 6, 8, 5, 9&#125;; heapSort(arr); System.out.println("排序后=" + Arrays.toString(arr)); &#125; public static void heapSort(int arr[]) &#123; int temp = 0; // 1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125; /* * 2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端; * 3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for (int j = arr.length - 1; j &gt; 0; j--) &#123; // 交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); &#125; &#125; /** * 将一个数组(二叉树), 调整成一个大顶堆 * &lt;p&gt; * 功能： 完成将以 i 对应的非叶子节点的树调整成大顶堆 * 举例int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到&#123;4, 9, 8, 5, 6&#125; * 如果我们再次调用adjustHeap 传入的是i = 0 =&gt; 得到&#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125; * * @param arr 待调整的数组 * @param i 表示非叶子节点在数组中索引 * @param length 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int length) &#123; // 先取出当前元素的值，保存在临时变量 int temp = arr[i]; //1. k = i * 2 + 1, k 是 i 节点的左子节点 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; // 说明左子节点的值小于右子节点的值 if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; // k 指向右子节点 k++; &#125; // 如果子节点大于父节点 if (arr[k] &gt; temp) &#123; // 把较大的值赋给当前节点 arr[i] = arr[k]; // !!! i 指向k,继续循环比较 i = k; &#125; else &#123; break; &#125; &#125; // 当for循环结束后，我们已经将以 i 为父节点的树的最大值，放在了最顶(局部) // 将 temp 值放到调整后的位置 arr[i] = temp; &#125;&#125; 常用排序算法总结和对比 相关术语解释： 稳定：如果a 原本在b 前面，而a=b，排序之后a 仍然在b 的前面； 不稳定：如果a 原本在b 的前面，而a=b，排序之后a 可能会出现在b 的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间； 空间复杂度：运行完一个程序所需内存的大小； n: 数据规模； k: “桶”的个数； In-place: 不占用额外内存； Out-place: 占用额外内存；]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建个人博客（Hexo篇）]]></title>
    <url>%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Hexo%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本教程使用的软件版本： win10（1903 版） git（2.22） node（10.15.3） hexo（3.9.0） 搭建步骤安装git访问git官网下载后完成安装，完成后右键会有git bash命令行出现，以后用这个命令行工具来操作git。推荐廖雪峰老师的git教程，可以用作入门。 安装后输入查看版本命令git --version来验证git是否已正常安装。 安装node访问node官网下载适合版本完成安装，完成后输入查看版本命令node-v和npm-v来验证git是否已正常安装。 安装cnpm因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以需要安装cnpm。 输入如下命令： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后输入查看版本命令cpnm -v验证是否已正常安装。 安装hexo输入如下命令： 1cnpm install -g hexo-cli 安装完成后依然通过查看版本命令hexo -v来验证是否已正常安装完成。 安装完成后开始进行初始化工作。 在本地磁盘建立博客文件夹，以我为例，在G盘建立blog文件夹。然后通过git bash或者cmd窗口进入到该文件夹，输入hexo init命令。 新建完成后可以发现hexo在文件夹下自动建立了如下目录： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的 配置 信息，我们在此会配置大部分的参数。 scaffolds：模版文件夹。当新建文章时，hexo会根据 scaffold 来建立文件。 source：资源文件夹。是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes：主题文件夹。hexo会根据主题来生成静态页面。 到此，安装基本完成了，下面我们来执行hexo s命令在本地启动看一下效果。 提示我们启动在了4000端口，可以通过Ctrl+C命令来终止服务。在浏览器输入http://localhost:4000就能看到生成的博客了。 写下第一篇文章下面介绍一下怎样完成一篇文章并发布。 在 blog 目录下输入hexo n &quot;我的第一篇文章&quot;命令来新建一篇文件。然后cd到 source/_post 目录，会发现hexo已经帮我们新建了我的第一篇文章.md文件，我们通过typora编辑该文件，完成第一篇文章。 下面回到blog目录，依次执行hexo clean和hexo generate命令来生成刚才编写的文章。 完成后，还是执行hexo s命令在本地查看一下我们刚才写的文章。 将hexo部署到github在github新建仓库。注意，仓库名称应该是用户名+.github.io，因为只有这样，部署到GitHub page时才会被识别。 本地安装hexo的git插件执行cpnm install hexo-deployer-git --save命令完成安装。 修改配置文件修改 blog 目录下的 _config.yml 文件，将git仓库地址和分支信息填上。 发布到github执行hexo d命令将本地文章同步到github。第一次需要输入github账号和密码。 执行完成后，可以看到已经同步到远端了。 到github仓库中查看一下，同样也发现文章已经同步过来了。 在浏览器输入http://yourname.github.io就能看到你的博客了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>零基础</tag>
        <tag>个人网站</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
