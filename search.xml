<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（查找算法）]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（排序算法）]]></title>
    <url>%2F2019%2F07%2F13%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排序算法的介绍排序也称排序算法(Sort Algorithm)，排序是将一组数据，依照指定的顺序进行排列的过程。 排序的分类 内部排序法 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 外部排序法 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。 常见的排序算法分类 算法的时间复杂度度量一个程序(算法)执行时间的两种方法 事后统计的方法 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。 事前估算的方法 通过分析某个算法的时间复杂度来判断哪个算法更优。 时间频度 基本介绍一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 举例说明-基本案例比如计算1-100 所有数字之和, 我们设计两种算法： 举例说明-忽略常数项 结论： 2n+20 和2n 随着n 变大，执行曲线无限接近, 20 可以忽略。 3n+10 和3n 随着n 变大，执行曲线无限接近, 10 可以忽略。 举例说明-忽略常数低次项 结论： 2n2+3n+10 和2n2 随着n 变大, 执行曲线无限接近, 可以忽略3n+10。 n2+5n+20 和n2随着n 变大,执行曲线无限接近, 可以忽略5n+20。 举例说明-忽略系数 结论: 随着n 值变大，5n2+7n 和3n2 + 2n ，执行曲线重合, 说明这种情况下, 5 和3 可以忽略。 而n3+5n 和6n3+4n ，执行曲线分离，说明多少次方式关键。 时间复杂度 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n 的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 T(n) 不同，但时间复杂度可能相同。如：T(n)=n2+7n+6 与T(n)=3n2+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n2)。 计算时间复杂度的方法： 用常数1 代替运行时间中的所有加法常数T(n)=n2+7n+6 =&gt; T(n)=n2+7n+1 修改后的运行次数函数中，只保留最高阶项T(n)=n2+7n+1 =&gt; T(n) = n2 去除最高阶项的系数T(n) = n2 =&gt; T(n) = n2 =&gt; O(n2) 常见的时间复杂度 常数阶O(1) 对数阶O(log2n) 线性阶O(n) 线性对数阶O(nlog2n) 平方阶O(n2) 立方阶O(n3) k 次方阶O(nk) 指数阶O(2n) 常见的时间复杂度对应的图： 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 从图中可见，我们应该尽可能避免使用指数阶的算法。 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 。 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n) 说明： 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2) 。 O(log2) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 。 线性阶O(n) 说明： 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 。 线性对数阶O(nlogN) 说明： 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 。 平方阶O(n2) 说明： 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n2)，这段代码其实就是嵌套了2层n循环 ，它的时间复杂度就是 O(n2)，即 O(n2) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n) 。 立方阶O(n3)、K次方阶O(nk)说明： 参考上面的O(n2) 去理解就好了，O(n3)相当于三层n循环，其它的类似。 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图)。 算法的空间复杂度基本介绍 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n 的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n 有关，它随着n 的增大而增大，当n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法， 基数排序就属于这种情况。 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。 冒泡排序基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 冒泡排序思路分析图 结论： 一共进行数组的大小-1 次大的循环 每一趟排序的次数在逐渐的减少 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 代码实现对数组[3, 9, -1, 10, -2]进行冒泡排序。 123456789101112131415161718192021public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; // 临时变量 int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag 判断元素是否进行过交换。从而减少不必要的比较。 12345678910111213141516171819202122232425262728293031public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; // 临时变量 int temp = 0; // 标识变量，表示是否进行过交换 boolean flag = false; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); if (!flag) &#123; // 在一趟排序中, 一次交换都没有发生过 break; &#125; else &#123; // 重置flag!!!, 进行下次判断 flag = false; &#125; &#125; &#125;&#125; 选择排序基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。 选择排序思想选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i 次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1 次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1 次，得到一个按排序码从小到大排列的有序序列。 选择排序思路分析图 对一个数组的选择排序再进行讲解 代码实现对数组[101, 34, 119, 1]进行选择排序。 12345678910111213141516171819202122232425262728public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 说明假定的最小值，并不是最小 if (min &gt; arr[j]) &#123; // 重置min min = arr[j]; // 重置minIndex minIndex = j; &#125; &#125; // 将最小值，放在arr[i], 即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println("第" + (i + 1) + "轮后~~"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 插入排序基本介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。 插入排序思想插入排序（Insertion Sorting）的基本思想是：把n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 插入排序思路分析图 代码实现对数组[101, 34, 119, 1]进行选择排序。 1234567891011121314151617181920212223242526272829303132public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; int insertValue = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) &#123; insertIndex = i - 1; insertValue = arr[i]; // 定义待插入的数 // 说明 // 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]) &#123; // 移位 排序过的元素右移一格 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; // 当退出while 循环时，说明插入的位置找到, insertIndex + 1 // 这里我们判断是否需要赋值 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertValue; &#125; System.out.println("第" + i + "轮插入"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 希尔排序简单插入排序存在的问题我们看简单的插入排序可能存在的问题。数组arr = {2,3,4,5,6,1} 这时需要插入的数1(最小), 这样的过程是： 123456&#123;2,3,4,5,6,6&#125;&#123;2,3,4,5,5,6&#125;&#123;2,3,4,4,5,6&#125;&#123;2,3,3,4,5,6&#125;&#123;2,2,3,4,5,6&#125;&#123;1,2,3,4,5,6&#125; 结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。 基本介绍希尔排序是希尔（Donald Shell）于1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1 时，整个文件恰被分成一组，算法便终止。 希尔排序思路分析图 代码实现对数组[8,9,1,7,2,3,5,4,6,0]进行希尔排序。 123456789101112131415161718192021222324252627public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; int count = 0; // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素开始，逐个对每个组来排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j - gap]; j -= gap; &#125; //当退出while 后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; System.out.println("希尔排序第" + (++count) + "轮=" + Arrays.toString(arr)); &#125; &#125;&#125; 快速排序基本介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序思路分析图 代码实现对数组[-9,78,0,23,-567,70]进行快速排序。 归并排序基本介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 归并排序思想 归并排序思路分析图再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。 代码实现基数排序基数排序(桶排序)基本介绍 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法。 基数排序(Radix Sort)是桶排序的扩展。 基数排序是1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 基数排序思路分析图将数组{53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。 代码实现基数排序的说明 基数排序是对传统桶排序的扩展，速度很快。 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成OutOfMemoryError 。 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，请参考这篇文章。 常用排序算法总结和对比 相关术语解释： 稳定：如果a 原本在b 前面，而a=b，排序之后a 仍然在b 的前面； 不稳定：如果a 原本在b 的前面，而a=b，排序之后a 可能会出现在b 的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间； 空间复杂度：运行完一个程序所需内存的大小； n: 数据规模； k: “桶”的个数； In-place: 不占用额外内存； Out-place: 占用额外内存；]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建个人博客（Hexo篇）]]></title>
    <url>%2F2019%2F07%2F08%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Hexo%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本教程使用的软件版本： win10（1903 版） git（2.22） node（10.15.3） hexo（3.9.0） 搭建步骤安装git访问git官网下载后完成安装，完成后右键会有git bash命令行出现，以后用这个命令行工具来操作git。推荐廖雪峰老师的git教程，可以用作入门。 安装后输入查看版本命令git --version来验证git是否已正常安装。 安装node访问node官网下载适合版本完成安装，完成后输入查看版本命令node-v和npm-v来验证git是否已正常安装。 安装cnpm因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以需要安装cnpm。 输入如下命令： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后输入查看版本命令cpnm -v验证是否已正常安装。 安装hexo输入如下命令： 1cnpm install -g hexo-cli 安装完成后依然通过查看版本命令hexo -v来验证是否已正常安装完成。 安装完成后开始进行初始化工作。 在本地磁盘建立博客文件夹，以我为例，在G盘建立blog文件夹。然后通过git bash或者cmd窗口进入到该文件夹，输入hexo init命令。 新建完成后可以发现hexo在文件夹下自动建立了如下目录： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的 配置 信息，我们在此会配置大部分的参数。 scaffolds：模版文件夹。当新建文章时，hexo会根据 scaffold 来建立文件。 source：资源文件夹。是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes：主题文件夹。hexo会根据主题来生成静态页面。 到此，安装基本完成了，下面我们来执行hexo s命令在本地启动看一下效果。 提示我们启动在了4000端口，可以通过Ctrl+C命令来终止服务。在浏览器输入http://localhost:4000就能看到生成的博客了。 写下第一篇文章下面介绍一下怎样完成一篇文章并发布。 在 blog 目录下输入hexo n &quot;我的第一篇文章&quot;命令来新建一篇文件。然后cd到 source/_post 目录，会发现hexo已经帮我们新建了我的第一篇文章.md文件，我们通过typora编辑该文件，完成第一篇文章。 下面回到blog目录，依次执行hexo clean和hexo generate命令来生成刚才编写的文章。 完成后，还是执行hexo s命令在本地查看一下我们刚才写的文章。 将hexo部署到github在github新建仓库。注意，仓库名称应该是用户名+.github.io，因为只有这样，部署到GitHub page时才会被识别。 本地安装hexo的git插件执行cpnm install hexo-deployer-git --save命令完成安装。 修改配置文件修改 blog 目录下的 _config.yml 文件，将git仓库地址和分支信息填上。 发布到github执行hexo d命令将本地文章同步到github。第一次需要输入github账号和密码。 执行完成后，可以看到已经同步到远端了。 到github仓库中查看一下，同样也发现文章已经同步过来了。 在浏览器输入http://yourname.github.io就能看到你的博客了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>零基础</tag>
        <tag>个人网站</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
