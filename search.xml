<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SpringBoot%20java-jar%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[在spring boot里，很吸引人的一个特性是可以直接把应用打包成为一个jar/war，然后这个jar/war是可以直接启动的，而不需要另外配置一个Web Server。那么spring boot如何启动的，今天我们就来一起探究一下它的原理？首先我们来创建一个基本的spring boot工程来帮助我们分析，本次spring boot版本为 2.2.5.RELEASE。 1234567@SpringBootApplicationpublic class SpringBootDemo &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootDemo.class); &#125;&#125; 下面是pom依赖： 12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;finalName&gt;springboot-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 创建完工程后，执行maven的打包命令，会生成两个jar文件： springboot-demo.jar springboot-demo.jar.original 其中springboot-demo.jar.original是默认的maven-jar-plugin生成的包。springboot-demo.jar.jar是spring boot maven插件生成的jar包，里面包含了应用的依赖，以及spring boot相关的类。下面称之为executable jar。后者仅包含应用编译后的本地资源，而前者引入了相关的第三方依赖，这点从文件大小也能看出。 关于executable jar，spring boot官方文档 中是这样解释的。 Executable jars (sometimes called “fat jars”) are archives containing your compiled classes along with all of the jar dependencies that your code needs to run. Executable jar（有时称为“fat jars”）是包含您的已编译类以及代码需要运行的所有jar依赖项的归档文件。 Java does not provide any standard way to load nested jar files (that is, jar files that are themselves contained within a jar). This can be problematic if you need to distribute a self-contained application that can be run from the command line without unpacking. Java没有提供任何标准的方式来加载嵌套的jar文件（即，它们本身包含在jar中的jar文件）。如果您需要分发一个自包含的应用程序，而该应用程序可以从命令行运行而无需解压缩，则可能会出现问题。 To solve this problem, many developers use “shaded” jars. A shaded jar packages all classes, from all jars, into a single “uber jar”. The problem with shaded jars is that it becomes hard to see which libraries are actually in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars. 为了解决这个问题，许多开发人员使用 shaded jars。 一个 shaded jar 将来自所有jar的所有类打包到一个 uber(超级)jar 中。 shaded jars的问题在于，很难查看应用程序中实际包含哪些库。 如果在多个jar中使用相同的文件名（但具有不同的内容），也可能会产生问题。 Spring Boot takes a different approach and lets you actually nest jars directly. Spring Boot采用了另一种方法，实际上允许您直接嵌套jar。 Java标准中是没有来加载嵌套的jar文件，就是jar中的jar的方式的，为了解决这一问题，spring boot采用了不同于shaded jars的另一种方式。 Executable Jar 文件结构那么具体是如何实现的呢？带着这个疑问，先来查看spring boot打好的包的目录结构（不重要的省略掉）： main├── BOOT-INF│ ├── classes│ │ └── com│ │ &nbsp;&nbsp;&nbsp; └── example│ │ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── spring│ │ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── boot│ │ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── demo│ │ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── SpringBootDemo.class # 用户-启动类 │ │ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── controller│ │ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── HelloController.class│ └── lib│ &nbsp;&nbsp;&nbsp; ├── classmate-1.5.1.jar│ &nbsp;&nbsp;&nbsp; ├── hibernate-validator-6.0.18.Final.jar│ &nbsp;&nbsp;&nbsp; ├── jackson-xxx.jar│ &nbsp;&nbsp;&nbsp; ├── log4j-xxx.jar│ &nbsp;&nbsp;&nbsp; ├── logback-xxx.jar│ &nbsp;&nbsp;&nbsp; ├── spring-xxx.jar│ &nbsp;&nbsp;&nbsp; ├── tomcat-xxx.jar│ &nbsp;&nbsp;&nbsp; ├── 省略…├── META-INF│ ├── MANIFEST.MF│ └── maven│ &nbsp;&nbsp;&nbsp; └── com.example│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── spring-boot-demo│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── pom.properties # 用户-配置文件│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── pom.xml├── org│ └── springframework│ &nbsp;&nbsp;&nbsp; └── boot│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── loader│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── ExecutableArchiveLauncher.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── JarLauncher.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── LaunchedURLClassLoader.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── Launcher.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── MainMethodRunner.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── PropertiesLauncher$1.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── PropertiesLauncher$ArchiveEntryFilter.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── PropertiesLauncher.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── WarLauncher.class│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── archive│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; │ ├── 省略…│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── data│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; │ ├── 省略…│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ├── jar│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; │ ├── 省略…│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── util│ &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └── SystemPropertyUtils.class&lt;br 简单来看，FatJar 解压之后包括三个文件夹： ├── BOOT-INF # 存放的是我们业务相关的，包括业务开发的类和配置文件，以及依赖的jar│ ├── classes│ └── lib├── META-INF # 包括 MANIFEST.MF 描述文件和 maven 的构建信息│ ├── MANIFEST.MF│ └── maven└── org └── springframework ​ └── boot ​ └── springframework ​ └── loader # Spring boot loader 相关类 可以发现， Application classes should be placed in a nested BOOT-INF/classes directory. Dependencies should be placed in a nested BOOT-INF/lib directory. 我们通常在服务器中使用java -jar 命令启动我们的应用程序，在Java官方文档是这样描述的： Executes a program encapsulated in a JAR file. The filename argument is the name of a JAR file with a manifest that contains a line in the form Main-Class:classname that defines the class with the public static void main(String[] args) method that serves as your application’s starting point. 执行封装在JAR文件中的程序。filename参数是具有清单的JAR文件的名称，该清单包含Main-Class：classname形式的行，该行使用公共静态void main（String [] args）方法定义该类，该方法充当应用程序的起点。 When you use the -jar option, the specified JAR file is the source of all user classes, and other class path settings are ignored. 使用-jar选项时，指定的JAR文件是所有用户类的源，而其他类路径设置将被忽略。 简单说就是，java -jar 命令引导的具体启动类必须配置在 MANIFEST.MF 文件的 Main-Class 属性中，该命令用来引导标准可执行的jar文件，读取的是 MANIFEST.MF文件的Main-Class 属性值，Main-Class 也就是定义包含了main方法的类代表了应用程序执行入口类。 那么回过头再去看下之前打包好、解压之后的文件目录，找到 /META-INF/MANIFEST.MF 文件，看下元数据： Manifest-Version: 1.0Implementation-Title: spring-boot-demoImplementation-Version: 1.0-SNAPSHOTStart-Class: com.example.spring.boot.demo.SpringBootDemoSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.2.5.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher 可以看到Main-Class是org.springframework.boot.loader.JarLauncher ，说明项目的启动入口并不是我们自己定义的启动类，而是JarLauncher。而我们自己的项目引导类com.example.spring.boot.demo.SpringBootDemo，定义在了Start-Class属性中，这个属性并非Java标准的MANIFEST.MF文件属性。 spring-boot-maven-plugin 打包过程我们并没有添加org.springframework.boot.loader下的这些类的依赖，那么它们是如何被打包在 FatJar 里面的呢？这就必须要提到spring-boot-maven-plugin插件的工作机制了 。对于每个新建的 spring boot工程，可以在其 pom.xml 文件中看到如下插件： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 这个是 SpringBoot 官方提供的用于打包 FatJar 的插件，org.springframework.boot.loader 下的类其实就是通过这个插件打进去的； 当我们执行package命令的时候会看到下面这样的日志： 12[INFO] --- spring-boot-maven-plugin:2.2.5.RELEASE:repackage (repackage) @ spring-boot-demo ---[INFO] Replacing main artifact with repackaged archive repackage目标对应的将执行到org.springframework.boot.maven.RepackageMojo#execute，该方法的主要逻辑是调用了org.springframework.boot.maven.RepackageMojo#repackage 123456789101112131415161718192021222324252627282930313233343536private void repackage() throws MojoExecutionException &#123; // 获取使用maven-jar-plugin生成的jar，最终的命名将加上.orignal后缀 Artifact source = getSourceArtifact(); // 最终文件，即Fat jar File target = getTargetFile(); // 获取重新打包器，将重新打包成可执行jar文件 Repackager repackager = getRepackager(source.getFile()); // 查找并过滤项目运行时依赖的jar Set&lt;Artifact&gt; artifacts = filterDependencies(this.project.getArtifacts(), getFilters(getAdditionalFilters())); // 将artifacts转换成libraries Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack, getLog()); try &#123; // 提供Spring Boot启动脚本 LaunchScript launchScript = getLaunchScript(); // 执行重新打包逻辑，生成最后fat jar repackager.repackage(target, libraries, launchScript); &#125; catch (IOException ex) &#123; throw new MojoExecutionException(ex.getMessage(), ex); &#125; // 将source更新成 xxx.jar.orignal文件 updateArtifact(source, target, repackager.getBackupFile());&#125;// 继续跟踪getRepackager这个方法，知道Repackager是如何生成的，也就大致能够推测出内在的打包逻辑。private Repackager getRepackager(File source) &#123; Repackager repackager = new Repackager(source, this.layoutFactory); repackager.addMainClassTimeoutWarningListener(new LoggingMainClassTimeoutWarningListener()); // 设置main class的名称，如果不指定的话则会查找第一个包含main方法的类，repacke最后将会设置org.springframework.boot.loader.JarLauncher repackager.setMainClass(this.mainClass); if (this.layout != null) &#123; getLog().info("Layout: " + this.layout); repackager.setLayout(this.layout.layout()); &#125; return repackager;&#125; repackager设置了 layout方法的返回对象，也就是org.springframework.boot.loader.tools.Layouts.Jar 12345678910111213141516171819202122232425262728293031/** * Executable JAR layout. */public static class Jar implements RepackagingLayout &#123; @Override public String getLauncherClassName() &#123; return "org.springframework.boot.loader.JarLauncher"; &#125; @Override public String getLibraryDestination(String libraryName, LibraryScope scope) &#123; return "BOOT-INF/lib/"; &#125; @Override public String getClassesLocation() &#123; return ""; &#125; @Override public String getRepackagedClassesLocation() &#123; return "BOOT-INF/classes/"; &#125; @Override public boolean isExecutable() &#123; return true; &#125;&#125; layout我们可以将之翻译为文件布局，或者目录布局，代码一看清晰明了，同时我们又发现了定义在MANIFEST.MF 文件的Main-Class属性org.springframework.boot.loader.JarLauncher了，看来我们的下面的重点就是这个JarLauncher了。 JarLauncher构造过程因为org.springframework.boot.loader.JarLauncher的类是在spring-boot-loader中的，关于spring-boot-loader，spring boot的github上是这样介绍的： Spring Boot Loader provides the secret sauce that allows you to build a single jar file that can be launched using java -jar. Generally you will not need to use spring-boot-loader directly, but instead work with the Gradle or Maven plugin. Spring Boot Loader提供了秘密工具，可让您构建可以使用java -jar启动的单个jar文件。通常，您不需要直接使用spring-boot-loader，而可以使用Gradle或Maven插件。 但是若想在IDEA中来看源码，需要在pom文件中引入如下配置： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-loader&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 找到org.springframework.boot.loader.JarLauncher类 123456789101112131415161718192021222324252627public class JarLauncher extends ExecutableArchiveLauncher &#123; // BOOT-INF/classes/ static final String BOOT_INF_CLASSES = "BOOT-INF/classes/"; // BOOT-INF/lib/ static final String BOOT_INF_LIB = "BOOT-INF/lib/"; public JarLauncher() &#123; &#125; protected JarLauncher(Archive archive) &#123; super(archive); &#125; @Override protected boolean isNestedArchive(Archive.Entry entry) &#123; if (entry.isDirectory()) &#123; return entry.getName().equals(BOOT_INF_CLASSES); &#125; return entry.getName().startsWith(BOOT_INF_LIB); &#125; // main方法 public static void main(String[] args) throws Exception &#123; new JarLauncher().launch(args); &#125;&#125; 可以发现，JarLauncher定义了BOOT_INF_CLASSES和BOOT_INF_LIB两个常量，正好就是前面我们解压之后的两个文件目录。JarLauncher包含了一个main方法，作为应用的启动入口。 从 main 来看，只是构造了一个 JarLauncher对象，然后执行其 launch 方法 。再来看一下JarLauncher的继承结构： 构造JarLauncherd对象时会调用父类ExecutableArchiveLauncher的构造方法： 1234567891011121314151617181920212223242526public ExecutableArchiveLauncher() &#123; try &#123; // 构造 archive 对象 this.archive = createArchive(); &#125; catch (Exception ex) &#123; throw new IllegalStateException(ex); &#125;&#125;// 构造 archive 对象protected final Archive createArchive() throws Exception &#123; ProtectionDomain protectionDomain = getClass().getProtectionDomain(); CodeSource codeSource = protectionDomain.getCodeSource(); URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null; // 这里就是拿到当前的 classpath 的绝对路径 String path = (location != null) ? location.getSchemeSpecificPart() : null; if (path == null) &#123; throw new IllegalStateException("Unable to determine code source archive"); &#125; File root = new File(path); if (!root.exists()) &#123; throw new IllegalStateException("Unable to determine code source archive from " + root); &#125; // 将构造的archive 对象返回 return (root.isDirectory() ? new ExplodedArchive(root) : new JarFileArchive(root));&#125; Archive这里又需要我们先来了解一下Archive相关的概念。 archive即归档文件，这个概念在linux下比较常见 通常就是一个tar/zip格式的压缩包 jar是zip格式 123456public abstract class Archive &#123; public abstract URL getUrl(); public String getMainClass(); public abstract Collection&lt;Entry&gt; getEntries(); public abstract List&lt;Archive&gt; getNestedArchives(EntryFilter filter);&#125; Archive是在spring boot里抽象出来的用来统一访问资源的接口。该接口有两个实现，分别是ExplodedArchive和JarFileArchive。前者是一个文件目录，后者是一个jar，都是用来在文件目录和jar中寻找资源的，这里看到JarLauncher既支持jar启动，也支持文件系统启动，实际上我们在解压后的文件目录里执行 java org.springframework.boot.loader.JarLauncher 命令也是可以正常启动的。 在FatJar中，使用的是后者。Archive有一个自己的URL，比如 jar:file:/D:/java/workspace/spring-boot-bootstarp-demo/spring-boot-demo/target/springboot-demo.jar! 还有一个getNestedArchives方法，这个实际返回的是springboot-demo.jar/lib下面的jar的Archive列表。它们的URL是： jar:file:/D:/java/workspace/spring-boot-bootstarp-demo/spring-boot-demo/target/springboot-demo.jar!/BOOT-INF/lib/spring-boot-starter-web-2.2.5.RELEASE.jar! jar:file:/D:/java/workspace/spring-boot-bootstarp-demo/spring-boot-demo/target/springboot-demo.jar!/BOOT-INF/lib/spring-boot-starter-2.2.5.RELEASE.jar! jar:file:/D:/java/workspace/spring-boot-bootstarp-demo/spring-boot-demo/target/springboot-demo.jar!/BOOT-INF/lib/spring-boot-2.2.5.RELEASE.jar! jar:file:/D:/java/workspace/spring-boot-bootstarp-demo/spring-boot-demo/target/springboot-demo.jar!/BOOT-INF/lib/spring-boot-autoconfigure-2.2.5.RELEASE.jar!/ …… launch()执行流程archive构造完成后继续执行JarLauncher父类的Launcher的launch方法： 12345678910protected void launch(String[] args) throws Exception &#123; /* * 利用 java.net.URLStreamHandler 的扩展机制注册了SpringBoot的自定义的可以解析嵌套jar的协议。因为SpringBoot FatJar除包含传统Java Jar中的资源外还包含依赖的第三方Jar文件 * 当SpringBoot FatJar被java -jar命令引导时，其内部的Jar文件是无法被JDK的默认实现sun.net.www.protocol.jar.Handler当做classpath的，这就是SpringBoot的自定义协议的原因。 */ JarFile.registerUrlProtocolHandler(); // 通过 classpath 来构建一个 ClassLoader ClassLoader classLoader = createClassLoader(getClassPathArchives()); launch(args, getMainClass(), classLoader);&#125; 重点关注下createClassLoader(getClassPathArchives()) 构建ClassLoader的逻辑，getClassPathArchives()方法返回值作为参数，该方法为抽象方法，具体实现在子类ExecutableArchiveLauncher中： 123456@Overrideprotected List&lt;Archive&gt; getClassPathArchives() throws Exception &#123; List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(this.archive.getNestedArchives(this::isNestedArchive)); postProcessClassPathArchives(archives); return archives;&#125; 该方法会执行Archive接口定义的getNestedArchives方法返回的与指定过滤器匹配的条目的嵌套存档列表。从上文可以发现，这里的archive其实就是JarFileArchive ，传入的过滤器是JarLauncher#isNestedArchive方法引用 123456789@Overrideprotected boolean isNestedArchive(Archive.Entry entry) &#123; // entry是文件目录时，必须是我们自己的业务类所在的目录 BOOT-INF/classes/ if (entry.isDirectory()) &#123; return entry.getName().equals(BOOT_INF_CLASSES); &#125; // entry是Jar文件时，需要在依赖的文件目录 BOOT-INF/lib/下面 return entry.getName().startsWith(BOOT_INF_LIB);&#125; getClassPathArchives方法通过过滤器将BOOT-INF/classes/和BOOT-INF/lib/下的嵌套存档作为List&lt;Archive&gt;返回参数传入createClassLoader方法中。 123456789101112protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception &#123; List&lt;URL&gt; urls = new ArrayList&lt;&gt;(archives.size()); for (Archive archive : archives) &#123; // 前面说到，archive有一个自己的URL的，获得archive的URL放到list中 urls.add(archive.getUrl()); &#125; return createClassLoader(urls.toArray(new URL[0]));&#125;protected ClassLoader createClassLoader(URL[] urls) throws Exception &#123; return new LaunchedURLClassLoader(urls, getClass().getClassLoader());&#125; createClassLoader()方法目的是为得到的URL们创建一个类加载器 LaunchedURLClassLoader，构造时传入了当前Launcher的类加载器作为其父加载器，通常是系统类加载器。下面重点看一下LaunchedURLClassLoader的构造过程： 123public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) &#123; super(urls, parent);&#125; LaunchedURLClassLoader是spring boot自己定义的类加载器，继承了JDK的URLClassLoader并重写了loadClass方法，也就是说它修改了默认的类加载方式，定义了自己的类加载规则，可以从前面得到的 List&lt;Archive&gt;中加载依赖包的class文件了 。 LaunchedURLClassLoader创建完成后，我们回到Launcher中，下一步就是执行launch的重载方法了。 1launch(args, getMainClass(), classLoader); 在此之前，会调用getMainClass方法并将其返回值作为参。 getMainClass的实现在Launcher的子类ExecutableArchiveLauncher中： 123456789101112131415@Overrideprotected String getMainClass() throws Exception &#123; // 从 archive 中拿到 Manifest文件 Manifest manifest = this.archive.getManifest(); String mainClass = null; if (manifest != null) &#123; // 就是MANIFEST.MF 文件中定义的Start-Class属性，也就是我们自己写的com.example.spring.boot.demo.SpringBootDemo这个类 mainClass = manifest.getMainAttributes().getValue("Start-Class"); &#125; if (mainClass == null) &#123; throw new IllegalStateException("No 'Start-Class' manifest entry specified in " + this); &#125; // 返回mainClass return mainClass;&#125; 得到mainClass后，执行launch的重载方法： 12345678910protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception &#123; // 将自定义的LaunchedURLClassLoader设置为当前线程上下文类加载器 Thread.currentThread().setContextClassLoader(classLoader); // 构建一个 MainMethodRunner 实例对象来启动应用 createMainMethodRunner(mainClass, args, classLoader).run();&#125;protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args, ClassLoader classLoader) &#123; return new MainMethodRunner(mainClass, args);&#125; MainMethodRunner对象构建完成后，调用它的run方法： 12345678public void run() throws Exception &#123; // 使用当前线程上下文类加载器也就是自定义的LaunchedURLClassLoader来加载我们自己写的com.example.spring.boot.demo.SpringBootDemo这个类 Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader().loadClass(this.mainClassName); // 找到SpringBootDemo的main方法 Method mainMethod = mainClass.getDeclaredMethod("main", String[].class); // 通过反射的方式调用main方法 mainMethod.invoke(null, new Object[] &#123; this.args &#125;);&#125; 至此，我们自己的main方法开始被调用，所有我们自己的应用程序类文件均可通过/BOOT-INF/classes加载，所有依赖的第三方jar均可通过/BOOT-INF/lib加载，然后就开始了spring boot的启动流程了。 debug技巧以上就是spring boot通过java -jar命令启动的原理了，了解了原理以后我们可不可以通过debug来进一步加深一下理解呢？通常我们在IDEA里启动时是直接运行main方法，因为依赖的Jar都让IDEA放到classpath里了，所以spring boot直接启动就完事了，并不会通过上面的方式来启动。不过我们可以通过配置IDEA的 run/debug configurations 配置 JAR Application 来实现通过Jar方式启动。 当我们做了以上设置后，就可以来方便的在IDEA里来dubug源码了。 小结本文通过JarLauncher为切入点，介绍了spring boot的java -jar的启动方式，阐述了JarLauncher启动的基本工作原理，同时简单介绍了相关的spring-boot-maven-plugin插件和Archive、LaunchedURLClassLoader等相关概念，希望能够对大家的理解有所帮助。]]></content>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（常用算法）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%89.html</url>
    <content type="text"><![CDATA[二分查找算法基本介绍 前面介绍的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间O(log2n) ，即查找到需要的目标位置最多只需要log2n 步，假设从[0,99]的队列(100 个数，即n=100)中寻到目标数30，则需要查找步数为log2100 , 即最多需要查找7 次( 2^6 &lt; 100 &lt; 2^7) 代码实现要求：对数组{1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成。 1234567891011121314151617181920212223242526272829303132333435public class BinarySearchNoRecur &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 8, 10, 11, 67, 100&#125;; int index = binarySearch(arr, 10); System.out.println("index=" + index); &#125; /** * 二分查找的非递归实现 * * @param arr 待查找的数组, arr 是升序排序 * @param target 需要查找的数 * @return 返回对应下标，-1 表示没有找到 */ public static int binarySearch(int[] arr, int target) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; // 说明要继续查找 int mid = (left + right) / 2; if (arr[mid] == target) &#123; return mid; &#125; else if (arr[mid] &gt; target) &#123; // 需要向左边查找 right = mid - 1; &#125; else &#123; // 需要向右边查找 left = mid + 1; &#125; &#125; return -1; &#125;&#125; 分治算法基本介绍分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题： 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 基本步骤分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 合并：将各个子问题的解合并为原问题的解。 设计模式 应用场景-汉诺塔汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 思路分析 如果是有一个盘， A-&gt;C 如果我们有n &gt;= 2 情况，我们总是可以看做是两个盘1.最下边的盘2. 上面的盘 先把最上面的盘A-&gt;B 把最下边的盘A-&gt;C 把B 塔的所有盘从B-&gt;C 代码实现1234567891011121314151617181920212223242526public class Hanoitower &#123; public static void main(String[] args) &#123; hanoiTower(5, 'A', 'B', 'C'); &#125; /** * 汉诺塔的移动的方法 * 使用分治算法 */ public static void hanoiTower(int num, char a, char b, char c) &#123; //如果只有一个盘 if (num == 1) &#123; System.out.println("第1个盘从" + a + "-&gt;" + c); &#125; else &#123; //如果我们有n &gt;= 2 情况，我们总是可以看做是两个盘1.最下边的一个盘2. 上面的所有盘 //1. 先把最上面的所有盘A-&gt;B， 移动过程会使用到c hanoiTower(num - 1, a, c, b); //2. 把最下边的盘A-&gt;C System.out.println("第" + num + "个盘从" + a + "-&gt;" + c); //3. 把B 塔的所有盘从B-&gt;C , 移动过程使用到a 塔 hanoiTower(num - 1, b, a, c); &#125; &#125;&#125; 动态规划算法基本介绍 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解) 动态规划可以通过填表的方式来逐步推进，得到最优解 应用场景-背包问题有一个背包，容量为4 磅， 现有如下物品 物品 重量 价格 吉他（G） 1 1500 音响（S） 4 3000 电脑（L） 3 2000 要求达到的目标为装入的背包的总价值最大，并且重量不超出 要求装入的物品不能重复 思路分析 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01 背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于01 背包，即每个物品最多放一个。而无限背包可以转化为01 背包。 算法的主要思想，利用动态规划来解决。每次遍历到的第i 个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n 个物品，设v[i]、w[i]分别为第i 个物品的价值和重量，C 为背包的容量。再令v[i][j]表示在前i 个物品中能够装入容量为j 的背包中的最大价值。则我们有下面的结果： 12345678910(1) v[i][0]=v[0][j]=0; //表示填入表第一行和第一列是0(2) 当w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略(3) 当j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;// 当准备加入的新增的商品的容量小于等于当前背包的容量,// 装入的方式:v[i-1][j]： 就是上一个单元格的装入的最大值v[i] : 表示当前商品的价值v[i-1][j-w[i]] ： 装入i-1 商品，到剩余空间j-w[i]的最大值当j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class KnapsackProblem &#123; public static void main(String[] args) &#123; //物品的重量 int[] w = &#123;1, 4, 3&#125;; //物品的价值这里val[i] 就是前面讲的v[i] int[] val = &#123;1500, 3000, 2000&#125;; //背包的容量 int m = 4; //物品的个数 int n = val.length; //创建二维数组， //v[i][j] 表示在前i 个物品中能够装入容量为j 的背包中的最大价值 int[][] v = new int[n + 1][m + 1]; //为了记录放入商品的情况，我们定一个二维数组 int[][] path = new int[n + 1][m + 1]; //初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0 for (int i = 0; i &lt; v.length; i++) &#123; //将第一列设置为0 v[i][0] = 0; &#125; for (int i = 0; i &lt; v[0].length; i++) &#123; //将第一行设置0 v[0][i] = 0; &#125; //根据前面得到公式来动态规划处理 //不处理第一行i 是从1 开始的 for (int i = 1; i &lt; v.length; i++) &#123; //不处理第一列, j 是从1 开始的 for (int j = 1; j &lt; v[0].length; j++) &#123; if (w[i - 1] &gt; j) &#123; // 因为我们程序i 是从1 开始的，因此原来公式中的w[i] 修改成w[i-1] v[i][j] = v[i - 1][j]; &#125; else &#123; //因为我们的i 从1 开始的， 因此公式需要调整成 //v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]); //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else 来体现公式 if (v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123; v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]; //把当前的情况记录到path path[i][j] = 1; &#125; else &#123; v[i][j] = v[i - 1][j]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; v.length; i++) &#123; for (int j = 0; j &lt; v[i].length; j++) &#123; System.out.print(v[i][j] + " "); &#125; System.out.println(); &#125; System.out.println("============================"); //输出最后我们是放入的哪些商品 //遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入 //行的最大下标 int i = path.length - 1; //列的最大下标 int j = path[0].length - 1; while (i &gt; 0 &amp;&amp; j &gt; 0) &#123; //从path 的最后开始找 if (path[i][j] == 1) &#123; System.out.printf("第%d 个商品放入到背包\n", i); j -= w[i - 1]; &#125; i--; &#125; &#125;&#125; KMP 算法应用场景字符串匹配问题：1) 有一个字符串str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串str2=”ABCDABD”2) 现在要判断str1 是否含有str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 暴力匹配算法如果用暴力匹配的思路，并假设现在str1 匹配到i 位置，子串str2 匹配到j 位置，则有: 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ViolenceMatch &#123; public static void main(String[] args) &#123; String str1 = "BBC ABCDAB ABCDABCDABDE"; String str2 = "ABCDABD"; int index = violenceMatch(str1, str2); System.out.println("index=" + index); &#125; /** * 暴力匹配算法实现 */ public static int violenceMatch(String str1, String str2) &#123; char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; // i 索引指向s1 int i = 0; // j 索引指向s2 int j = 0; // 保证匹配时，不越界 while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123; if (s1[i] == s2[j]) &#123; // 匹配成功 i++; j++; &#125; else &#123; // 没有匹配成功 // 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。 i = i - (j - 1); j = 0; &#125; &#125; //判断是否匹配成功 if (j == s2Len) &#123; return i - j; &#125; else &#123; return -1; &#125; &#125;&#125; 基本介绍 KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为“KMP 算法”，常用于在一个文本串S 内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris 三人于1977 年联合发表，故取这3 人的姓氏命名此算法. KMP 方法算法就利用之前判断过信息，通过一个next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next 数组找到，前面匹配过的位置，省去了大量的计算时间 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html 思路分析举例来说，有一个字符串Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串Str2 =“ABCDABD”？ 首先，用Str1 的第一个字符和Str2 的第一个字符去比较，不符合，关键词向后移动一位 重复第一步，还是不符合，再后移 一直重复，直到Str1 有一个字符与Str2 的第一个字符符合为止 接着比较字符串和搜索词的下一个字符，还是符合 遇到Str1 有一个字符与Str2 对应的字符不符合 这时候，想到的是继续遍历Str1 的下一个字符，重复第1 步。(其实是很不明智的，因为此时BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D 不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) 怎么做到把刚刚重复的步骤省略掉？可以对Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍 已知空格与D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B 对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：移动位数= 已匹配的字符数- 对应的部分匹配值因为6 - 2 等于4，所以将搜索词向后移动4 位。 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数= 2 - 0，结果为2，于是将搜索词向后移2 位。 因为空格与A 不匹配，继续后移一位 逐位比较，直到发现C 与D 不匹配。于是，移动位数= 6 - 2，继续将搜索词向后移动4 位 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数= 7 - 0，再将搜索词向后移动7 位，这里就不再重复了。 介绍《部分匹配表》怎么产生的先介绍前缀，后缀是什么 “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， ”A”的前缀和后缀都为空集，共有元素的长度为0； ”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； ”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； ”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； ”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； ”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； ”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD,D]，共有元素的长度为0。 ”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class KMPAlgorithm &#123; public static void main(String[] args) &#123; String str1 = "BBC ABCDAB ABCDABCDABDE"; String str2 = "ABCDABD"; int[] next = kmpNext(str2); System.out.println(Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println("index=" + index); &#125; /** * kmp 搜索算法 * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1 就是没有匹配到，否则返回第一个匹配的位置 */ public static int kmpSearch(String str1, String str2, int[] next) &#123; //遍历 for (int i = 0, j = 0; i &lt; str1.length(); i++) &#123; //需要处理str1.charAt(i) ！= str2.charAt(j), 去调整j 的大小 //KMP 算法核心点, 可以验证... while (j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123; j = next[j - 1]; &#125; if (str1.charAt(i) == str2.charAt(j)) &#123; j++; &#125; if (j == str2.length()) &#123; //找到了// j = 3 i return i - j + 1; &#125; &#125; return -1; &#125; /** * 获取到一个字符串(子串) 的部分匹配值表 */ public static int[] kmpNext(String dest) &#123; //创建一个next 数组保存部分匹配值 int[] next = new int[dest.length()]; //如果字符串是长度为1 部分匹配值就是0 next[0] = 0; for (int i = 1, j = 0; i &lt; dest.length(); i++) &#123; //当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j //直到我们发现有dest.charAt(i) == dest.charAt(j)成立才退出 //这是kmp 算法的核心点 while (j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123; j = next[j - 1]; &#125; //当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1 if (dest.charAt(i) == dest.charAt(j)) &#123; j++; &#125; next[i] = j; &#125; return next; &#125;&#125; 贪心算法基本介绍 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 应用场景-集合覆盖假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号 思路分析如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n 个广播台，则广播台的组合总共有2n -1 个,假设每秒可以计算10 个子集， 如图: 使用贪心算法，效率高： 目前并没有算法可以快速计算得到准备的值， 使用贪心算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合: 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 重复第1 步直到覆盖了全部的地区 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class GreedyAlgorithm &#123; public static void main(String[] args) &#123; //创建广播电台,放入到Map HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;&gt;(); //将各个电台放入到broadcasts HashSet&lt;String&gt; hashSet1 = new HashSet&lt;&gt;(); hashSet1.add("北京"); hashSet1.add("上海"); hashSet1.add("天津"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;&gt;(); hashSet2.add("广州"); hashSet2.add("北京"); hashSet2.add("深圳"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;&gt;(); hashSet3.add("成都"); hashSet3.add("上海"); hashSet3.add("杭州"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;&gt;(); hashSet4.add("上海"); hashSet4.add("天津"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;&gt;(); hashSet5.add("杭州"); hashSet5.add("大连"); //加入到map broadcasts.put("K1", hashSet1); broadcasts.put("K2", hashSet2); broadcasts.put("K3", hashSet3); broadcasts.put("K4", hashSet4); broadcasts.put("K5", hashSet5); //allAreas 存放所有的地区 HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;(); allAreas.add("北京"); allAreas.add("上海"); allAreas.add("天津"); allAreas.add("广州"); allAreas.add("深圳"); allAreas.add("成都"); allAreas.add("杭州"); allAreas.add("大连"); //创建ArrayList, 存放选择的电台集合 ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;(); //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集 HashSet&lt;String&gt; tempSet = new HashSet&lt;&gt;(); //定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key //如果maxKey 不为null , 则会加入到selects String maxKey = null; // 如果allAreas 不为0, 则表示还没有覆盖到所有的地区 while (allAreas.size() != 0) &#123; //每进行一次while,需要 maxKey = null; //遍历broadcasts, 取出对应key for (String key : broadcasts.keySet()) &#123; //每进行一次for tempSet.clear(); //当前这个key 能够覆盖的地区 HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); //求出tempSet 和allAreas 集合的交集, 交集会赋给tempSet tempSet.retainAll(allAreas); //如果当前这个集合包含的未覆盖地区的数量，比maxKey 指向的集合地区还多 //就需要重置maxKey // tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的 if (tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123; maxKey = key; &#125; &#125; //maxKey != null, 就应该将maxKey 加入selects if (maxKey != null) &#123; selects.add(maxKey); //将maxKey 指向的广播电台覆盖的地区，从allAreas 去掉 allAreas.removeAll(broadcasts.get(maxKey)); &#125; &#125; //[K1,K2,K3,K5] System.out.println("得到的选择结果是" + selects); &#125;&#125; 注意事项 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区 但是我们发现K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的K1, K2, K3,K5 虽然是满足条件，但是并不是最优的 普里姆算法应用场景-修路问题 有胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把7 个村庄连通 各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 思路： 将10 条边，连接即可，但是总的里程数不是最小.正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少。 最小生成树修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树。 N 个顶点，一定有N-1 条边 包含全部顶点 N-1 条边都在图中 举例说明(如图) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 基本介绍普利姆(Prim)算法求最小生成树，也就是在包含n 个顶点的连通图中，找出只有(n-1)条边包含所有n 个顶点的连通子图，也就是所谓的极小连通子图。普利姆的算法如下: 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合 若从顶点u 开始构造最小生成树，则从集合V 中取出顶点u 放入集合U 中，标记顶点v 的visited[u]=1 若集合U 中顶点ui 与集合V-U 中的顶点vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj 加入集合U 中，将边（ui,vj）加入集合D 中，标记visited[vj]=1 重复步骤②，直到U 与V 相等，即所有顶点都被标记为访问过，此时D 中有n-1 条边 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解. 图解普利姆算法 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class PrimAlgorithm &#123; public static void main(String[] args) &#123; char[] data = new char[]&#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; int vertexs = data.length; //邻接矩阵的关系使用二维数组表示,10000 这个大数，表示两个点不联通 int[][] weight = new int[][]&#123; &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;, &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;, &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;, &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;, &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;, &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;, &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;&#125;; //创建MGraph 对象 MGraph graph = new MGraph(vertexs); //创建一个MinTree 对象 MinTree minTree = new MinTree(); minTree.createGraph(graph, vertexs, data, weight); minTree.showGraph(graph); minTree.prim(graph, 1); &#125;&#125;/** * 创建最小生成树-&gt;村庄的图 */class MinTree &#123; /** * 创建图的邻接矩阵 * * @param graph 图对象 * @param vertexs 图对应的顶点个数 * @param data 图的各个顶点的值 * @param weight 图的邻接矩阵 */ public void createGraph(MGraph graph, int vertexs, char data[], int[][] weight) &#123; int i, j; for (i = 0; i &lt; vertexs; i++) &#123; graph.data[i] = data[i]; for (j = 0; j &lt; vertexs; j++) &#123; graph.weight[i][j] = weight[i][j]; &#125; &#125; &#125; /** * 显示图的邻接矩阵 */ public void showGraph(MGraph graph) &#123; for (int[] link : graph.weight) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; /** * 编写prim 算法，得到最小生成树 * * @param graph 图 * @param v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1... */ public void prim(MGraph graph, int v) &#123; //visited[] 标记结点(顶点)是否被访问过 //visited[] 默认元素的值都是0, 表示没有访问过 int visited[] = new int[graph.vertexs]; //把当前这个结点标记为已访问 visited[v] = 1; //h1 和h2 记录两个顶点的下标 int h1 = -1; int h2 = -1; //将minWeight 初始成一个大数，后面在遍历过程中，会被替换 int minWeight = 10000; //因为有graph.verxs 顶点，普利姆算法结束后，有graph.verxs-1 边 for (int k = 1; k &lt; graph.vertexs; k++) &#123; //这个是确定每一次生成的子图，和哪个结点的距离最近 // i 结点表示被访问过的结点 for (int i = 0; i &lt; graph.vertexs; i++) &#123; //j 结点表示还没有访问过的结点 for (int j = 0; j &lt; graph.vertexs; j++) &#123; if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123; //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边) minWeight = graph.weight[i][j]; h1 = i; h2 = j; &#125; &#125; &#125; //找到一条边是最小 System.out.println("边&lt;" + graph.data[h1] + "," + graph.data[h2] + "&gt; 权值:" + minWeight); //将当前这个结点标记为已经访问 visited[h2] = 1; //minWeight 重新设置为最大值10000 minWeight = 10000; &#125; &#125;&#125;class MGraph &#123; /** * 表示图的节点个数 */ int vertexs; /** * 存放结点数据 */ char[] data; /** * 存放边，就是我们的邻接矩阵 */ int[][] weight; public MGraph(int vertexs) &#123; this.vertexs = vertexs; data = new char[vertexs]; weight = new int[vertexs][vertexs]; &#125; &#125; 克鲁斯卡尔算法应用场景-公交站问题 某城市新增7 个站点(A, B, C, D, E, F, G) ，现在需要修路把7 个站点连通 各个站点的距离用边线表示(权) ，比如A – B 距离12 公里 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? 基本介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择n-1 条边，并保证这n-1 条边不构成回路。 具体做法：首先构造一个只含n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 思路分析以城市公交站问题来图解说明克鲁斯卡尔算法的原理和步骤： 在含有n 个顶点的连通图中选择n-1 条边，构成一棵极小连通子图，并使该连通子图中n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。 例如，对于如上图G4 所示的连通网可以有多棵权值总和不相同的生成树。 图解说明以上图G4 为例，来对克鲁斯卡尔进行演示(假设，用数组R 保存最小生成树结果)。 将边&lt;E,F&gt;加入R 中。 边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R 中。 将边&lt;C,D&gt;加入R 中。 上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R 中。 将边&lt;D,E&gt;加入R 中。 上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R 中。 将边&lt;B,F&gt;加入R 中。 上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R 中。 将边&lt;E,G&gt;加入R 中。 上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R 中。 将边&lt;A,B&gt;加入R 中。 上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R 中。 此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。 算法分析根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：问题一：对图的所有边按照权值大小进行排序。问题二：将边添加到最小生成树中时，怎么样判断是否形成了回路。问题一很好解决，采用排序算法进行排序即可。问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 回路问题 在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R 中之后，这几条边的顶点就都有了终点： C 的终点是F。 D 的终点是F。 E 的终点是F。 F 的终点是F。 关于终点的说明： 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C 和E 的终点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class KruskalCase &#123; /** * 边的个数 */ private int edgeNum; /** * 顶点数组 */ private char[] vertexs; /** * 邻接矩阵 */ private int[][] matrix; /** * 使用INF 表示两个顶点不能连通 */ private static final int INF = Integer.MAX_VALUE; public static void main(String[] args) &#123; char[] vertexs = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; int matrix[][] = &#123; /*A*/ &#123;0, 12, INF, INF, INF, 16, 14&#125;, /*B*/ &#123;12, 0, 10, INF, INF, 7, INF&#125;, /*C*/ &#123;INF, 10, 0, 3, 5, 6, INF&#125;, /*D*/ &#123;INF, INF, 3, 0, 4, INF, INF&#125;, /*E*/ &#123;INF, INF, 5, 4, 0, 2, 8&#125;, /*F*/ &#123;16, 7, 6, INF, 2, 0, 9&#125;, /*G*/ &#123;14, INF, INF, INF, 8, 9, 0&#125;&#125;; KruskalCase kruskalCase = new KruskalCase(vertexs, matrix); kruskalCase.kruskal(); &#125; public KruskalCase(char[] vertexs, int[][] matrix) &#123; //初始化顶点数和边的个数 int vlen = vertexs.length; //初始化顶点, 复制拷贝的方式 this.vertexs = new char[vlen]; for (int i = 0; i &lt; vertexs.length; i++) &#123; this.vertexs[i] = vertexs[i]; &#125; //初始化边, 使用的是复制拷贝的方式 this.matrix = new int[vlen][vlen]; for (int i = 0; i &lt; vlen; i++) &#123; for (int j = 0; j &lt; vlen; j++) &#123; this.matrix[i][j] = matrix[i][j]; &#125; &#125; //统计边的条数 for (int i = 0; i &lt; vlen; i++) &#123; for (int j = i + 1; j &lt; vlen; j++) &#123; if (this.matrix[i][j] != INF) &#123; edgeNum++; &#125; &#125; &#125; &#125; /** * 打印邻接矩阵 */ public void print() &#123; System.out.println("邻接矩阵为: \n"); for (int i = 0; i &lt; vertexs.length; i++) &#123; for (int j = 0; j &lt; vertexs.length; j++) &#123; System.out.printf("%12d", matrix[i][j]); &#125; System.out.println(); &#125; &#125; public void kruskal() &#123; //表示最后结果数组的索引 int index = 0; //用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点 int[] ends = new int[edgeNum]; //创建结果数组, 保存最后的最小生成树 EData[] res = new EData[edgeNum]; //获取图中所有的边的集合， 一共有12 边 EData[] edges = getEdges(); System.out.println("图的边的集合=" + Arrays.toString(edges) + " 共" + edges.length); //按照边的权值大小进行排序(从小到大) sortEdges(edges); //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入res,否则不能加入 for (int i = 0; i &lt; edgeNum; i++) &#123; //获取到第i 条边的第一个顶点(起点) int p1 = getPosition(edges[i].start); //获取到第i 条边的第2 个顶点(终点) int p2 = getPosition(edges[i].end); //获取p1 这个顶点在已有最小生成树中的终点 int m = getEnd(ends, p1); //获取p2 这个顶点在已有最小生成树中的终点 int n = getEnd(ends, p2); //是否构成回路 if (m != n) &#123; //没有构成回路 // 设置m 在"已有最小生成树"中的终点&lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0] ends[m] = n; //有一条边加入到res 数组 res[index++] = edges[i]; &#125; &#125; //统计并打印"最小生成树", 输出rets System.out.println("最小生成树为"); for (int i = 0; i &lt; index; i++) &#123; System.out.println(res[i]); &#125; &#125; /** * 对边进行排序处理, 冒泡排序 * * @param edges 边的集合 */ private void sortEdges(EData[] edges) &#123; for (int i = 0; i &lt; edges.length - 1; i++) &#123; for (int j = 0; j &lt; edges.length - 1 - i; j++) &#123; if (edges[j].weight &gt; edges[j + 1].weight) &#123; EData temp = edges[j]; edges[j] = edges[j + 1]; edges[j + 1] = temp; &#125; &#125; &#125; &#125; /** * 功能: 获取下标为i 的顶点的终点, 用于后面判断两个顶点的终点是否相同 * * @param ends 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成 * @param i 表示传入的顶点对应的下标 * @return 返回的就是下标为i 的这个顶点对应的终点的下标 */ private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0] while (ends[i] != 0) &#123; i = ends[i]; &#125; return i; &#125; /** * @param ch 顶点的值，比如'A','B' * @return 返回ch 顶点对应的下标，如果找不到，返回-1 */ private int getPosition(char ch) &#123; for (int i = 0; i &lt; vertexs.length; i++) &#123; if (vertexs[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; /** * 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组是通过matrix 邻接矩阵来获取 * EData[] 形式[['A','B', 12], ['B','F',7], .....] */ private EData[] getEdges() &#123; int index = 0; EData[] edges = new EData[edgeNum]; for (int i = 0; i &lt; vertexs.length; i++) &#123; for (int j = i + 1; j &lt; vertexs.length; j++) &#123; if (matrix[i][j] != INF) &#123; edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]); &#125; &#125; &#125; return edges; &#125;&#125;/** * 创建一个类EData ，它的对象实例就表示一条边 */class EData &#123; /** * 边的起点 */ char start; /** * 边的终点 */ char end; /** * 边的权值 */ int weight; public EData(char start, char end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125; @Override public String toString() &#123; return "EData [&lt;" + start + ", " + end + "&gt;= " + weight + "]"; &#125;&#125; 迪杰斯特拉算法应用场景-最短路径问题 胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G 点出发，需要分别把邮件分别送到A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里 问：如何计算出G 村庄到其它各个村庄的最短距离? 如果从其它点出发到各个点的最短距离又是多少? 基本介绍迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 思路分析 设置出发顶点为v，顶点集合V{v1,v2,vi…}，v 到V 中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v 到图中各顶点的距离(到自身可以看作0，v 到vi 距离对应为di) 从Dis 中选择值最小的di 并移出Dis 集合，同时移出V 集合中对应的顶点vi，此时的v 到vi 即为最短路径 更新Dis 集合，更新规则为：比较v 到V 集合中顶点的距离值，与v 通过vi 到V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi 到达的) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class DijkstraAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; //邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; // 表示不可以连接 final int N = 65535; matrix[0] = new int[]&#123;N, 5, 7, N, N, N, 2&#125;; matrix[1] = new int[]&#123;5, N, N, 9, N, N, 3&#125;; matrix[2] = new int[]&#123;7, N, N, N, 8, N, N&#125;; matrix[3] = new int[]&#123;N, 9, N, N, N, 4, N&#125;; matrix[4] = new int[]&#123;N, N, 8, N, N, 5, 4&#125;; matrix[5] = new int[]&#123;N, N, N, 4, 5, N, 6&#125;; matrix[6] = new int[]&#123;2, 3, N, N, 4, 6, N&#125;; Graph graph = new Graph(vertex, matrix); graph.showGraph(); graph.dsj(6); graph.showDijkstra(); &#125;&#125;class Graph &#123; /** * 顶点数组 */ private char[] vertex; /** * 邻接矩阵 */ private int[][] matrix; /** * 已经访问的顶点的集合 */ private VisitedVertex vv; public Graph(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; &#125; public void showGraph() &#123; for (int[] link : matrix) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; /** * 迪杰斯特拉算法实现 * * @param index 表示出发顶点对应的下标 */ public void dsj(int index) &#123; vv = new VisitedVertex(vertex.length, index); //更新index 顶点到周围顶点的距离和前驱顶点 update(index); for (int i = 1; i &lt; vertex.length; i++) &#123; // 选择并返回新的访问顶点 index = vv.updateArr(); // 更新index 顶点到周围顶点的距离和前驱顶点 update(index); &#125; &#125; public void showDijkstra() &#123; vv.show(); &#125; /** * 更新index 下标顶点到周围顶点的距离和周围顶点的前驱顶点 */ private void update(int index) &#123; int len = 0; //根据遍历我们的邻接矩阵的matrix[index]行 for (int j = 0; j &lt; matrix[index].length; j++) &#123; // len 含义是: 出发顶点到index 顶点的距离 + 从index 顶点到j 顶点的距离的和 len = vv.getDis(index) + matrix[index][j]; // 如果j 顶点没有被访问过，并且len 小于出发顶点到j 顶点的距离，就需要更新 if (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123; //更新j 顶点的前驱为index 顶点 vv.updatePre(j, index); //更新出发顶点到j 顶点的距离 vv.updateDis(j, len); &#125; &#125; &#125;&#125;/** * 已访问顶点集合 */class VisitedVertex &#123; /** * 记录各个顶点是否访问过1 表示访问过,0 未访问,会动态更新 */ public int[] already_arr; /** * 每个下标对应的值为前一个顶点下标, 会动态更新 */ public int[] pre_visited; /** * 记录出发顶点到其他所有顶点的距离,比如G 为出发顶点，就会记录G 到其它顶点的距离，会动态更新，求 * 的最短距离就会存放到dis */ public int[] dis; /** * @param length 表示顶点的个数 * @param index 出发顶点对应的下标, 比如G 顶点，下标就是6 */ public VisitedVertex(int length, int index) &#123; this.already_arr = new int[length]; this.pre_visited = new int[length]; this.dis = new int[length]; //初始化dis 数组 Arrays.fill(dis, 65535); //设置出发顶点被访问过 this.already_arr[index] = 1; //设置出发顶点的访问距离为0 this.dis[index] = 0; &#125; /** * 判断index 顶点是否被访问过 */ public boolean in(int index) &#123; return already_arr[index] == 1; &#125; /** * 更新出发顶点到index 顶点的距离 */ public void updateDis(int index, int len) &#123; dis[index] = len; &#125; /** * 更新pre 这个顶点的前驱顶点为index 顶点 */ public void updatePre(int pre, int index) &#123; pre_visited[pre] = index; &#125; /** * 返回出发顶点到index 顶点的距离 */ public int getDis(int index) &#123; return dis[index]; &#125; /** * 继续选择并返回新的访问顶点，比如这里的G 完后，就是A 点作为新的访问顶点(注意不是出发顶点) */ public int updateArr() &#123; int min = 65535, index = 0; for (int i = 0; i &lt; already_arr.length; i++) &#123; if (already_arr[i] == 0 &amp;&amp; dis[i] &lt; min) &#123; min = dis[i]; index = i; &#125; &#125; //更新index 顶点被访问过 already_arr[index] = 1; return index; &#125; public void show() &#123; System.out.println("=========================="); //输出already_arr for (int i : already_arr) &#123; System.out.print(i + " "); &#125; System.out.println(); //输出pre_visited for (int i : pre_visited) &#123; System.out.print(i + " "); &#125; System.out.println(); //输出dis for (int i : dis) &#123; System.out.print(i + " "); &#125; System.out.println(); //为了好看最后的最短距离，我们处理 char[] vertex = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; int count = 0; for (int i : dis) &#123; if (i != 65535) &#123; System.out.print(vertex[count] + "(" + i + ") "); &#125; else &#123; System.out.println("N "); &#125; count++; &#125; System.out.println(); &#125; &#125; 弗洛伊德算法基本介绍 和Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径。 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 弗洛伊德算法VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。 思路分析 设置顶点vi 到顶点vk 的最短路径已知为Lik，顶点vk 到vj 的最短路径已知为Lkj，顶点vi 到vj 的路径为Lij，则vi 到vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得vi 到vj 的最短路径。 至于vi 到vk 的最短路径Lik 或者vk 到vj 的最短路径Lkj，是以同样的方式获得。 示例：求最短路径为例说明。 弗洛伊德算法的步骤：第一轮循环中，以A(下标为：0)作为中间顶点【即把A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表和前驱关系】，距离表和前驱关系更新为： 分析如下： 以A 顶点作为中间顶点是，B-&gt;A-&gt;C 的距离由N-&gt;9，同理C 到B；C-&gt;A-&gt;G 的距离由N-&gt;12，同理G 到C 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束 应用场景-最短路径问题 胜利乡有7 个村庄(A, B, C, D, E, F, G) 各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里 问：如何计算出各村庄到其它各村庄的最短距离? 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class FloydAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; //创建邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535; matrix[0] = new int[]&#123;0, 5, 7, N, N, N, 2&#125;; matrix[1] = new int[]&#123;5, 0, N, 9, N, N, 3&#125;; matrix[2] = new int[]&#123;7, N, 0, N, 8, N, N&#125;; matrix[3] = new int[]&#123;N, 9, N, 0, N, 4, N&#125;; matrix[4] = new int[]&#123;N, N, 8, N, 0, 5, 4&#125;; matrix[5] = new int[]&#123;N, N, N, 4, 5, 0, 6&#125;; matrix[6] = new int[]&#123;2, 3, N, N, 4, 6, 0&#125;; //创建Graph 对象 Graph graph = new Graph(vertex.length, matrix, vertex); //调用弗洛伊德算法 graph.floyd(); graph.show(); &#125;&#125;/** * 创建图 */class Graph &#123; /** * 存放顶点的数组 */ private char[] vertex; /** * 保存从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组 */ private int[][] dis; /** * 保存到达目标顶点的前驱顶点 */ private int[][] pre; /** * @param length 大小 * @param matrix 邻接矩阵 * @param vertex 顶点数组 */ public Graph(int length, int[][] matrix, char[] vertex) &#123; this.vertex = vertex; this.dis = matrix; this.pre = new int[length][length]; // 对pre 数组初始化, 注意存放的是前驱顶点的下标 for (int i = 0; i &lt; length; i++) &#123; Arrays.fill(pre[i], i); &#125; &#125; /** * 显示pre 数组和dis 数组 */ public void show() &#123; //为了显示便于阅读，我们优化一下输出 char[] vertex = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; for (int k = 0; k &lt; dis.length; k++) &#123; // 先将pre 数组输出的一行 for (int i = 0; i &lt; dis.length; i++) &#123; System.out.print(vertex[pre[k][i]] + " "); &#125; System.out.println(); // 输出dis 数组的一行数据 for (int i = 0; i &lt; dis.length; i++) &#123; System.out.print("(" + vertex[k] + "到" + vertex[i] + "的最短路径是" + dis[k][i] + ") "); &#125; System.out.println(); System.out.println(); &#125; &#125; public void floyd() &#123; //变量保存距离 int len = 0; //对中间顶点遍历， k 就是中间顶点的下标[A, B, C, D, E, F, G] for (int k = 0; k &lt; dis.length; k++) &#123; //从i 顶点开始出发[A, B, C, D, E, F, G] for (int i = 0; i &lt; dis.length; i++) &#123; //到达j 顶点// [A, B, C, D, E, F, G] for (int j = 0; j &lt; dis.length; j++) &#123; // =&gt; 求出从i 顶点出发，经过k 中间顶点，到达j 顶点距离 len = dis[i][k] + dis[k][j]; //如果len 小于dis[i][j] if (len &lt; dis[i][j]) &#123; //更新距离 dis[i][j] = len; //更新前驱顶点 pre[i][j] = pre[k][j]; &#125; &#125; &#125; &#125; &#125;&#125; 马踏棋盘算法基本介绍 马踏棋盘算法也被称为骑士周游问题。 将马随机放在国际象棋的8×8 棋盘Board[07][07]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64 个方格。 游戏演示: http://www.4399.com/flash/146267_2.htm 思路分析 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53 个点，如图：走到了第53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… 对第一种实现方式的思路图解： 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class HorseChessboard &#123; /** * 棋盘的行数 */ private static int X; /** * 棋盘的列数 */ private static int Y; /** * 创建一个数组，标记棋盘的各个位置是否被访问过 */ private static boolean[] visited; /** * 使用一个属性，标记是否棋盘的所有位置都被访问 */ private static boolean finished; public static void main(String[] args) &#123; System.out.println("骑士周游算法，开始运行~~"); X = 8; Y = 8; //马儿初始位置的行，从1 开始编号 int row = 1; //马儿初始位置的列，从1 开始编号 int column = 1; //创建棋盘 int[][] chessboard = new int[X][Y]; visited = new boolean[X * Y]; long start = System.currentTimeMillis(); traversalChessboard(chessboard, row - 1, column - 1, 1); long end = System.currentTimeMillis(); System.out.println("共耗时: " + (end - start) + " 毫秒"); //输出棋盘的最后情况 for (int[] rows : chessboard) &#123; for (int step : rows) &#123; System.out.print(step + "\t"); &#125; System.out.println(); &#125; &#125; /** * 完成骑士周游问题的算法 * * @param chessboard 棋盘 * @param row 马儿当前的位置的行从0 开始 * @param column 马儿当前的位置的列从0 开始 * @param step 是第几步,初始位置就是第1 步 */ public static void traversalChessboard(int[][] chessboard, int row, int column, int step) &#123; chessboard[row][column] = step; //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36 //标记该位置已经访问 visited[row * X + column] = true; //获取当前位置可以走的下一个位置的集合 ArrayList&lt;Point&gt; ps = next(new Point(column, row)); //对ps 进行排序,排序的规则就是对ps 的所有的Point 对象的下一步的位置的数目，进行非递减排序 sort(ps); //遍历ps while (!ps.isEmpty()) &#123; //取出下一个可以走的位置 Point p = ps.remove(0); //判断该点是否已经访问过 if (!visited[p.y * X + p.x]) &#123; //说明还没有访问过 traversalChessboard(chessboard, p.y, p.x, step + 1); &#125; &#125; //判断马儿是否完成了任务，使用step 和应该走的步数比较， //如果没有达到数量，则表示没有完成任务，将整个棋盘置0 //说明: step &lt; X * Y 成立的情况有两种 //1. 棋盘到目前位置,仍然没有走完 //2. 棋盘处于一个回溯过程 if (step &lt; X * Y &amp;&amp; !finished) &#123; chessboard[row][column] = 0; visited[row * X + column] = false; &#125; else &#123; finished = true; &#125; &#125; public static ArrayList&lt;Point&gt; next(Point curPoint) &#123; //创建一个ArrayList ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;(); //创建一个Point Point p1 = new Point(); //表示马儿可以走5 这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走6 这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走7 这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走0 这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走1 这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走2 这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走3 这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123; ps.add(new Point(p1)); &#125; //判断马儿可以走4 这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123; ps.add(new Point(p1)); &#125; return ps; &#125; /** * 根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数 */ public static void sort(ArrayList&lt;Point&gt; ps) &#123; ps.sort(Comparator.comparingInt(o -&gt; next(o).size())); &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（递归）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89.html</url>
    <content type="text"><![CDATA[基本介绍简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。 调用机制 代码演示1234567891011121314151617181920212223242526272829public class RecursionTest &#123; public static void main(String[] args) &#123; // 通过打印问题，回顾递归调用机制 test(4); int res = factorial(3); System.out.println("res=" + res); &#125; //打印问题 public static void test(int n) &#123; if (n &gt; 2) &#123; test(n - 1); &#125; else &#123; System.out.println("n=" + n); &#125; &#125; //阶乘问题 public static int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return factorial(n - 1) * n; &#125; &#125;&#125; 应用场景 各种数学问题如: 8 皇后问题, 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等 将用栈解决的问题–&gt;第归代码比较简洁 重要规则递归需要遵守的重要规则： 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响, 比如n 变量 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class MiGong &#123; public static void main(String[] args) &#123; // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用1 表示墙 // 上下全部置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置挡板, 1 表示 map[3][1] = 1; map[3][2] = 1; // map[1][2] = 1; // map[2][2] = 1; // 输出地图 System.out.println("地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); //输出新的地图, 小球走过，并标识过的递归 System.out.println("小球走过，并标识过的地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; &#125; /** * 使用递归回溯来给小球找路 * 1. map 表示地图 * 2. i,j 表示从地图的哪个位置开始出发(1,1) * 3. 如果小球能到map[6][5] 位置，则说明通路找到. * 4. 约定： 当map[i][j] 为0 表示该点没有走过当为1 表示墙； 2 表示通路可以走； 3 表示该点已经走过，但是走不通 * 5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左, 如果该点走不通，再回溯 * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int[][] map, int i, int j) &#123; if (map[6][5] == 2) &#123; // 通路已经找到 return true; &#125; else &#123; if (map[i][j] == 0) &#123; // 如果当前这个点还没有走过 // 按照策略下-&gt;右-&gt;上-&gt;左走 // 假定该点是可以走通 map[i][j] = 2; if (setWay(map, i + 1, j)) &#123; // 向下走 return true; &#125; else if (setWay(map, i, j + 1)) &#123; // 向右走 return true; &#125; else if (setWay(map, i - 1, j)) &#123; // 向上走 return true; &#125; else if (setWay(map, i, j - 1)) &#123; // 向左走 return true; &#125; else &#123; // 说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是1， 2， 3 return false; &#125; &#125; &#125;&#125; 问题分析 小球得到的路径，和程序设置的找路策略有关即：找路的上下左右的顺序相关 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化 测试回溯现象 八皇后问题(回溯算法)基本介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。 思路分析 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适的位置 继续第三个皇后，还是第一列、第二列……直到第8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到 然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4 的步骤 说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。 arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} ，对应arr 下标表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1 个皇后，放在第i+1行的第val+1 列。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Queue8 &#123; /** * 定义一个max 表示共有多少个皇后 */ int max = 8; /** * 定义数组array, 保存皇后放置位置的结果,比如arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; */ int[] array = new int[max]; static int count = 0; static int judgeCount = 0; public static void main(String[] args) &#123; Queue8 queue8 = new Queue8(); queue8.check(0); System.out.printf("一共有%d 解法", count); System.out.printf("一共判断冲突的次数%d 次", judgeCount); &#125; /** * 放置第n 个皇后 * 特别注意： check 是每一次递归时，进入到check 中都有for(int i = 0; i &lt; max; i++)，因此会有回溯 */ private void check(int n) &#123; if(n == max) &#123; //n = 8 , 其实8 个皇后就已经放好 print(); return; &#125; for (int i = 0; i &lt; max; i++) &#123; //先把当前这个皇后n , 放到该行的第1 列 array[n] = i; //判断当放置第n 个皇后到i 列时，是否冲突 if(judge(n)) &#123; // 不冲突, 接着放n+1 个皇后,即开始递归 check(n+1); &#125; //如果冲突，就继续执行array[n] = i; 即将第n 个皇后，放置在本行所在列的下一列 i--&gt;i+1 &#125; &#125; /** * 查看当我们放置第n 个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突 * * @param n 表示第n 个皇后 */ private boolean judge(int n) &#123; judgeCount++; for (int i = 0; i &lt; n; i++) &#123; // 说明 // 1. array[i] == array[n] 表示判断第n 个皇后是否和前面的n-1 个皇后在同一列 // 2. Math.abs(n-i) == Math.abs(array[n] - array[i]), 横差=列差, 表示判断第n 个皇后是否和第i 皇后是否在同一斜线 // n = 1 放置第2 列1 n = 1 array[1] = 1 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 // 3. 判断是否在同一行, 没有必要，n 每次都在递增 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + " "); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（栈）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%88%EF%BC%89.html</url>
    <content type="text"><![CDATA[基本介绍 栈的英文为(stack)。 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。 图解方式说明出栈(pop)和入栈(push)的概念。 应用场景 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历。 图形的深度优先(depth 一first)搜索法。 思路分析要求：用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class ArrayStackDemo &#123; public static void main(String[] args) &#123; //先创建一个ArrayStack 对象-&gt;表示栈 ArrayStack stack = new ArrayStack(4); String key = ""; boolean loop = true; Scanner scanner = new Scanner(System.in); while (loop) &#123; System.out.println("show: 表示显示栈"); System.out.println("exit: 退出程序"); System.out.println("push: 表示添加数据到栈(入栈)"); System.out.println("pop: 表示从栈取出数据(出栈)"); System.out.println("请输入你的选择"); key = scanner.next(); switch (key) &#123; case "show": stack.list(); break; case "push": System.out.println("请输入一个数"); int value = scanner.nextInt(); stack.push(value); break; case "pop": try &#123; int res = stack.pop(); System.out.printf("出栈的数据是%d\n", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case "exit": scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~~"); &#125;&#125;/** * 定义一个ArrayStack 表示栈 */class ArrayStack &#123; /** * 栈的大小 */ private int maxSize; /** * 数组，数组模拟栈，数据就放在该数组 */ private int[] stack; /** * top 表示栈顶，初始化为-1 */ private int top = -1; public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; stack = new int[maxSize]; &#125; /** * 判断栈满 */ public boolean isFull() &#123; return top == maxSize - 1; &#125; /** * 判断栈空 */ public boolean isEmpty() &#123; return top == -1; &#125; /** * 入栈 */ public void push(int value) &#123; if (isFull()) &#123; System.out.println("栈满"); return; &#125; top++; stack[top] = value; &#125; /** * 出栈 */ public int pop() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException("栈空，没有数据~"); &#125; int value = stack[top]; top--; return value; &#125; /** * 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 */ public void list() &#123; if (isEmpty()) &#123; System.out.println("栈空，没有数据~~"); return; &#125; //需要从栈顶开始显示数据 for (int i = top; i &gt;= 0; i--) &#123; System.out.printf("stack[%d]=%d\n", i, stack[i]); &#125; &#125;&#125; 实现综合计算器(中缀表达式)要求：使用栈来实现综合计算器。计算式:[7*2*2-5+1-5+3-4] 点击计算【如下图】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236public class Calculator &#123; public static void main(String[] args) &#123; String expression = "7*2*2-5+1-5+3-4"; //创建两个栈，数栈，一个符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义需要的相关变量 //用于扫描 int index = 0; int num1 = 0; int num2 = 0; int oper = 0; int res = 0; //将每次扫描得到char保存到ch char ch = ' '; //用于拼接 多位数 String keepNum = ""; //开始while循环的扫描expression while (true) &#123; //依次得到expression 的每一个字符 ch = expression.substring(index, index + 1).charAt(0); //判断ch是什么，然后做相应的处理 if (operStack.isOper(ch)) &#123; //如果是运算符 //判断当前的符号栈是否为空 if (!operStack.isEmpty()) &#123; //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数, //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123; // 符号后 num1 = numStack.pop(); // 符号前 num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch); &#125; else &#123; //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈. operStack.push(ch); &#125; &#125; else &#123; //如果为空直接入符号栈.. // 1 + 3 operStack.push(ch); &#125; &#125; else &#123; //如果是数，则直接入数栈 //numStack.push(ch - 48); //? "1+3" '1' =&gt; 1 //分析思路 //1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数 //2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈 //3. 因此我们需要定义一个变量 字符串，用于拼接 //处理多位数 keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈 if (index == expression.length() - 1) &#123; numStack.push(Integer.parseInt(keepNum)); &#125; else &#123; //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 //注意是看后一位，不是index++ if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123; //如果后一位是运算符，则入栈 keepNum = "1" 或者 "123" numStack.push(Integer.parseInt(keepNum)); //重要的!!!!!!, keepNum清空 keepNum = ""; &#125; &#125; &#125; //让index + 1, 并判断是否扫描到expression最后. index++; if (index &gt;= expression.length()) &#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行. while (true) &#123; //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if (operStack.isEmpty()) &#123; break; &#125; // 符号后 num1 = numStack.pop(); // 符号前 num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res); &#125; //将数栈的最后数，pop出，就是结果 int res2 = numStack.pop(); System.out.printf("表达式 %s = %d", expression, res2); &#125;&#125;/** * 先创建一个栈,直接使用前面创建好 * 定义一个ArrayStack2 表示栈, 需要扩展功能 */class ArrayStack2 &#123; /** * 栈的大小 */ private int maxSize; /** * 数组，数组模拟栈，数据就放在该数组 */ private int[] stack; /** * top 表示栈顶，初始化为-1 */ private int top = -1; public ArrayStack2(int maxSize) &#123; this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; /** * 增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop */ public int peek() &#123; return stack[top]; &#125; /** * 判断栈满 */ public boolean isFull() &#123; return top == maxSize - 1; &#125; /** * 判断栈空 */ public boolean isEmpty() &#123; return top == -1; &#125; /** * 入栈 */ public void push(int value) &#123; if (isFull()) &#123; System.out.println("栈满"); return; &#125; top++; stack[top] = value; &#125; /** * 出栈 */ public int pop() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException("栈空，没有数据~"); &#125; int value = stack[top]; top--; return value; &#125; /** * 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 */ public void list() &#123; if (isEmpty()) &#123; System.out.println("栈空，没有数据~~"); return; &#125; //需要从栈顶开始显示数据 for (int i = top; i &gt;= 0; i--) &#123; System.out.printf("stack[%d]=%d\n", i, stack[i]); &#125; &#125; /** * 返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 * 数字越大，则优先级就越高. */ public int priority(int oper) &#123; // 假定目前的表达式只有 +, - , * , / if (oper == '*' || oper == '/') &#123; return 1; &#125; else if (oper == '+' || oper == '-') &#123; return 0; &#125; else &#123; return -1; &#125; &#125; /** * 判断是不是一个运算符 */ public boolean isOper(char val) &#123; return val == '+' || val == '-' || val == '*' || val == '/'; &#125; /** * 计算方法 */ public int cal(int num1, int num2, int oper) &#123; // res 用于存放计算的结果 int res = 0; switch (oper) &#123; case '+': res = num1 + num2; break; case '-': // 注意顺序 res = num2 - num1; break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; &#125; return res; &#125;&#125; 逆波兰计算器前缀表达式(波兰表达式) 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前。 举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6。 前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下: 从右至左扫描，将6、5、4、3压入堆栈； 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈； 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 中缀表达式 中缀表达式就是常见的运算表达式，如(3+4)×5-6。 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式)。 后缀表达式(逆波兰表达式) 后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后。 举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –。 后缀表达式的计算机求值例如: (3+4)×5-6 对应的后缀表达式就是3 4 + 5 × 6 - , 相对应的后缀表达式求值步骤如下: 从左至右扫描，将3 和4 压入堆栈； 遇到+运算符，因此弹出4 和3（4 为栈顶元素，3 为次顶元素），计算出3+4 的值，得7，再将7 入栈； 将5 入栈； 接下来是×运算符，因此弹出5 和7，计算出7×5=35，将35 入栈； 将6 入栈； 最后是-运算符，计算出35-6 的值，即29，由此得出最终结果。 要求：我们完成一个逆波兰计算器，要求完成如下任务: 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果。 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class PolandNotation &#123; public static void main(String[] args) &#123; //先定义给逆波兰表达式 //(30+4)×5-6 =&gt; 30 4 + 5 × 6 - =&gt; 164 // 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + //测试 //说明：为了方便，逆波兰表达式的数字和符号使用空格隔开 String suffixExpression = "3 4 + 5 * 6 -";// String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76 //思路 //1. 先将"3 4 + 5 × 6 - " =&gt; 放到ArrayList 中 //2. 将ArrayList 传递给一个方法，遍历ArrayList 配合栈完成计算 List&lt;String&gt; list = getListString(suffixExpression); System.out.println("rpnList=" + list); int res = calculate(list); System.out.println("计算的结果是=" + res); &#125; /** * 将一个逆波兰表达式， 依次将数据和运算符放入到ArrayList 中 */ public static List&lt;String&gt; getListString(String suffixExpression) &#123; //将suffixExpression 分割 String[] split = suffixExpression.split(" "); return Arrays.asList(split); &#125; /** * 完成对逆波兰表达式的运算 * 1)从左至右扫描，将3 和4 压入堆栈； * 2)遇到+运算符，因此弹出4 和3（4 为栈顶元素，3 为次顶元素），计算出3+4 的值，得7，再将7 入栈； * 3)将5 入栈； * 4)接下来是×运算符，因此弹出5 和7，计算出7×5=35，将35 入栈； * 5)将6 入栈； * 6)最后是-运算符，计算出35-6 的值，即29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; ls) &#123; // 创建给栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); // 遍历ls for (String item : ls) &#123; // 这里使用正则表达式来取出数 if (item.matches("\\d+")) &#123; // 匹配的是多位数，入栈 stack.push(item); &#125; else &#123; // pop 出两个数，并运算， 再入栈 // 栈顶元素 int num2 = Integer.valueOf(stack.pop()); // 次栈顶元素 int num1 = Integer.valueOf(stack.pop()); int res = 0; if (item.equals("+")) &#123; res = num1 + num2; &#125; else if (item.equals("-")) &#123; res = num1 - num2; &#125; else if (item.equals("*")) &#123; res = num1 * num2; &#125; else if (item.equals("/")) &#123; res = num1 / num2; &#125; else &#123; throw new RuntimeException("运算符有误"); &#125; //把res 入栈 stack.push("" + res); &#125; &#125; //最后留在stack 中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125; 中缀表达式转换为后缀表达式后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。具体步骤如下： 初始化两个栈：运算符栈s1 和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1 栈顶运算符的优先级： 如果s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1； 否则，将s1 栈顶的运算符弹出并压入到s2 中，再次转到(4.1)与s1 中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1； 如果是右括号“)”，则依次弹出s1 栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤2 至5，直到表达式的最右边 将s1 中剩余的运算符依次弹出并压入s2 依次弹出s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。 举例说明： 将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下 因此结果为:”1 2 3 + 4 × + 5 –”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public class PolandNotation &#123; public static void main(String[] args) &#123; //完成将一个中缀表达式转成后缀表达式的功能 //说明 //1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 – //2. 因为直接对str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =&gt; 中缀的表达式对应的List // 即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] //3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =&gt; ArrayList [1,2,3,+,4,*,+,5,–] String expression = "1+((2+3)*4)-5"; List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] System.out.println("中缀表达式对应的List=" + infixExpressionList); List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList); //ArrayList [1,2,3,+,4,*,+,5,–] System.out.println("后缀表达式对应的List" + suffixExpreesionList); System.out.printf("expression=%d", calculate(suffixExpreesionList)); &#125; /** * 即ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =&gt; ArrayList [1,2,3,+,4,*,+,5,–] * 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List */ public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123; // 定义两个栈 // 符号栈 Stack&lt;String&gt; s1 = new Stack&lt;&gt;(); // 说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出 // 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2 // Stack&lt;String&gt; s2 = new Stack&lt;&gt;(); // 储存中间结果的栈s2 // 储存中间结果的Lists2 List&lt;String&gt; s2 = new ArrayList&lt;&gt;(); //遍历ls for (String item : ls) &#123; //如果是一个数，加入s2 if (item.matches("\\d+")) &#123; s2.add(item); &#125; else if (item.equals("(")) &#123; s1.push(item); &#125; else if (item.equals(")")) &#123; //如果是右括号 ")"，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while (!s1.peek().equals("(")) &#123; s2.add(s1.pop()); &#125; //!!! 将 ( 弹出 s1栈， 消除小括号 s1.pop(); &#125; else &#123; //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 //问题：我们缺少一个比较优先级高低的方法 while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123; s2.add(s1.pop()); &#125; //还需要将item压入栈 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while (s1.size() != 0) &#123; s2.add(s1.pop()); &#125; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List return s2; &#125; /** * 将中缀表达式转成对应的List * s="1+((2+3)×4)-5"; */ public static List&lt;String&gt; toInfixExpressionList(String s) &#123; // 定义一个List,存放中缀表达式 对应的内容 List&lt;String&gt; ls = new ArrayList&lt;&gt;(); // 一个指针，用于遍历 中缀表达式字符串 int i = 0; // 对多位数的拼接 String str; // 每遍历到一个字符，就放入到c char c; do &#123; //如果c是一个非数字，需要加入到ls if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123; ls.add("" + c); //i需要后移 i++; &#125; else &#123; //如果是一个数，需要考虑多位数 //先将str 置成"" '0'[48]-&gt;'9'[57] str = ""; while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123; //拼接 str += c; i++; &#125; ls.add(str); &#125; &#125; while (i &lt; s.length()); return ls; &#125; /** * 将一个逆波兰表达式， 依次将数据和运算符放入到ArrayList 中 */ public static List&lt;String&gt; getListString(String suffixExpression) &#123; //将suffixExpression 分割 String[] split = suffixExpression.split(" "); return Arrays.asList(split); &#125; /** * 完成对逆波兰表达式的运算 * 1)从左至右扫描，将3 和4 压入堆栈； * 2)遇到+运算符，因此弹出4 和3（4 为栈顶元素，3 为次顶元素），计算出3+4 的值，得7，再将7 入栈； * 3)将5 入栈； * 4)接下来是×运算符，因此弹出5 和7，计算出7×5=35，将35 入栈； * 5)将6 入栈； * 6)最后是-运算符，计算出35-6 的值，即29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; ls) &#123; // 创建给栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); // 遍历ls for (String item : ls) &#123; // 这里使用正则表达式来取出数 if (item.matches("\\d+")) &#123; // 匹配的是多位数，入栈 stack.push(item); &#125; else &#123; // pop 出两个数，并运算， 再入栈 // 栈顶元素 int num2 = Integer.valueOf(stack.pop()); // 次栈顶元素 int num1 = Integer.valueOf(stack.pop()); int res = 0; if (item.equals("+")) &#123; res = num1 + num2; &#125; else if (item.equals("-")) &#123; res = num1 - num2; &#125; else if (item.equals("*")) &#123; res = num1 * num2; &#125; else if (item.equals("/")) &#123; res = num1 / num2; &#125; else &#123; throw new RuntimeException("运算符有误"); &#125; //把res 入栈 stack.push("" + res); &#125; &#125; //最后留在stack 中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125;/** * 编写一个类 Operation 可以返回一个运算符对应的优先级 */class Operation &#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; /** * 写一个方法，返回对应的优先级数字 */ public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case "+": result = ADD; break; case "-": result = SUB; break; case "*": result = MUL; break; case "/": result = DIV; break; default: System.out.println("不存在该运算符" + operation); break; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>逆波兰计算器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（链表）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89.html</url>
    <content type="text"><![CDATA[基本介绍链表是有序的列表，但是它在内存中是存储如下： 小结： 链表是以节点的方式来存储,是链式存储。 每个节点包含data 域， next 域：指向下一个节点。 链表的各个节点不一定是连续存储。 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定。 单链表(带头结点) 逻辑结构示意图如下： 应用实例使用带head 头的单向链表实现–水浒英雄排行榜管理完成对英雄人物的增删改查操作。 思路分析 添加节点 第一种方法：在添加英雄时，直接添加到链表的尾部。 第二种方式：在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)。 修改节点 先找到该节点，通过遍历。 temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname。 删除节点 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229public class SingleLinkedListDemo &#123; public static void main(String[] args) &#123; // 先创建节点 HeroNode hero1 = new HeroNode(1, "宋江", "及时雨"); HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟"); HeroNode hero3 = new HeroNode(3, "吴用", "智多星"); HeroNode hero4 = new HeroNode(4, "林冲", "豹子头"); // 创建要给链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入 // singleLinkedList.add(hero1); // singleLinkedList.add(hero4); // singleLinkedList.add(hero2); // singleLinkedList.add(hero3); // 加入按照编号的顺序 singleLinkedList.addByOrder(hero1); singleLinkedList.addByOrder(hero4); singleLinkedList.addByOrder(hero2); singleLinkedList.addByOrder(hero3); singleLinkedList.list(); // 测试修改节点的代码 HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~"); singleLinkedList.update(newHeroNode); System.out.println("修改后的链表情况~~"); singleLinkedList.list(); // 删除一个节点 singleLinkedList.del(1); singleLinkedList.del(4); System.out.println("删除后的链表情况~~"); singleLinkedList.list(); &#125;&#125;/** * 定义SingleLinkedList 管理我们的英雄 */class SingleLinkedList &#123; /** * 先初始化一个头节点, 头节点不要动, 不存放具体的数据 */ private HeroNode head = new HeroNode(0, "", ""); /** * 添加节点到单向链表 * 思路，当不考虑编号顺序时 * 1. 找到当前链表的最后节点 * 2. 将最后这个节点的next 指向新的节点 */ public void add(HeroNode heroNode) &#123; // 因为head 节点不能动，因此我们需要一个辅助遍历temp HeroNode temp = head; // 遍历链表，找到最后 while (true) &#123; // 找到链表的最后 if (temp.next == null) &#123; break; &#125; // 如果没有找到最后, 将将temp 后移 temp = temp.next; &#125; // 当退出while 循环时，temp 就指向了链表的最后 // 将最后这个节点的next 指向新的节点 temp.next = heroNode; &#125; /** * 第二种方式在添加英雄时，根据排名将英雄插入到指定位置 * (如果有这个排名，则添加失败，并给出提示) */ public void addByOrder(HeroNode heroNode) &#123; //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 //因为单链表，因为我们找的temp 是位于添加位置的前一个节点，否则插入不了 HeroNode temp = head; // flag 标志添加的编号是否存在，默认为false boolean flag = false; while (true) &#123; if (temp.next == null) &#123; // 说明temp 已经在链表的最后 break; &#125; if (temp.next.no &gt; heroNode.no) &#123; // 位置找到，就在temp 的后面插入 break; &#125; else if (temp.next.no == heroNode.no) &#123; // 说明希望添加的heroNode 的编号已存在 flag = true; // 说明编号存在 break; &#125; // 后移，遍历当前链表 temp = temp.next; &#125; // 判断flag 的值 if (flag) &#123; // 不能添加，说明编号存在 System.out.printf("准备插入的英雄的编号%d 已经存在了, 不能加入\n", heroNode.no); &#125; else &#123; // 插入到链表中, temp 的后面 heroNode.next = temp.next; temp.next = heroNode; &#125; &#125; /** * 修改节点的信息, 根据no 编号来修改，即no 编号不能改. * 根据newHeroNode 的no 来修改即可 */ public void update(HeroNode newHeroNode) &#123; // 判断是否空 if (head == null) &#123; System.out.println("链表为空~"); return; &#125; // 找到需要修改的节点, 根据no 编号 // 定义一个辅助变量 HeroNode temp = head.next; // 表示是否找到该节点 boolean flag = false; while (true) &#123; if (temp == null) &#123; // 已经遍历完链表 break; &#125; if (temp.no == newHeroNode.no) &#123; // 找到 flag = true; break; &#125; temp = temp.next; &#125; // 根据flag 判断是否找到要修改的节点 if (flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; // 没有找到 System.out.printf("没有找到编号%d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; /** * 删除节点 * 1. head 不能动，因此我们需要一个temp 辅助节点找到待删除节点的前一个节点 * 2. 说明我们在比较时，是temp.next.no 和需要删除的节点的no 比较 */ public void del(int no) &#123; HeroNode temp = head; // 标志是否找到待删除节点的 boolean flag = false; while (true) &#123; if (temp.next == null) &#123; // 已经到链表的最后 break; &#125; if (temp.next.no == no) &#123; // 找到的待删除节点的前一个节点temp flag = true; break; &#125; //temp 后移，遍历 temp = temp.next; &#125; // 判断flag if (flag) &#123; // 找到 // 可以删除 temp.next = temp.next.next; &#125; else &#123; System.out.printf("要删除的%d 节点不存在\n", no); &#125; &#125; /** * 显示链表[遍历] */ public void list() &#123; // 判断链表是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; HeroNode temp = head.next; while (true) &#123; // 判断是否到链表最后 if (temp == null) &#123; break; &#125; // 输出节点的信息 System.out.println(temp); // 将temp 后移， 一定小心 temp = temp.next; &#125; &#125;&#125;/** * 定义HeroNode ，每个HeroNode 对象就是一个节点 */class HeroNode &#123; public int no; public String name; public String nickname; /** * 指向下一个节点 */ public HeroNode next; public HeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return "HeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + ", nickname='" + nickname + '\'' + '&#125;'; &#125;&#125; 单链表面试题 求单链表中有效节点的个数。 12345678910111213141516171819/** * 获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点) * * @param head 链表的头节点 * @return 返回的就是有效节点的个数 */public static int getLength(HeroNode head) &#123; if (head.next == null) &#123; return 0; &#125; int length = 0; //定义一个辅助的变量, 这里我们没有统计头节点 HeroNode cur = head.next; while (cur.next != null) &#123; length++; cur = cur.next; &#125; return length;&#125; 查找单链表中的倒数第k 个结点。 1234567891011121314151617181920212223242526/** * 1. 编写一个方法，接收head 节点，同时接收一个index * 2. index 表示是倒数第index 个节点 * 3. 先把链表从头到尾遍历，得到链表的总的长度getLength * 4. 得到size 后，我们从链表的第一个开始遍历(size-index)个，就可以得到 * 5. 如果找到了，则返回该节点，否则返回null */public static HeroNode findLastIndexNode(HeroNode head, int index) &#123; //判断如果链表为空，返回null if (head.next == null) &#123; return null; &#125; //第一个遍历得到链表的长度(节点个数) int size = getLength(head); //第二次遍历size-index 位置，就是我们倒数的第K 个节点 //先做一个index 的校验 if (index &lt;= 0 || index &gt; size) &#123; return null; &#125; //定义给辅助变量， for 循环定位到倒数的index HeroNode cur = head.next; for (int i = 0; i &lt; size - index; i++) &#123; cur = cur.next; &#125; return cur;&#125; 单链表的反转。 123456789101112131415161718192021222324public static void reverseList(HeroNode head) &#123; // 如果当前链表为空，或者只有一个节点，无需反转，直接返回 if (head.next == null || head.next.next == null) &#123; return; &#125; // 定义一个辅助的指针(变量)，帮助我们遍历原来的链表 HeroNode cur = head.next; // 指向当前节点[cur]的下一个节点 HeroNode next = null; HeroNode reverseHead = new HeroNode(0, "", ""); // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 while (cur != null) &#123; // 先暂时保存当前节点的下一个节点，因为后面需要使用 next = cur.next; // 将cur 的下一个节点指向新的链表的最前端 cur.next = reverseHead.next; // 将cur 连接到新的链表上 reverseHead.next = cur; // 让cur 后移 cur = next; &#125; // 将head.next 指向reverseHead.next , 实现单链表的反转 head.next = reverseHead.next;&#125; 从尾到头打印单链表。 12345678910111213141516171819202122/** * 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 */public static void reversePrint(HeroNode head) &#123; if (head.next == null) &#123; // 空链表，不能打印 return; &#125; // 创建要给一个栈，将各个节点压入栈 Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;(); HeroNode cur = head.next; while (cur != null) &#123; stack.push(cur); //cur 后移，这样就可以压入下一个节点 cur = cur.next; &#125; // 将栈中的节点进行打印,pop 出栈 while (stack.size() &gt; 0) &#123; // stack 的特点是先进后出 System.out.println(stack.pop()); &#125;&#125; 双向链表操作分析和实现使用带head 头的双向链表实现–水浒英雄排行榜。管理单向链表的缺点分析： 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp 是待删除节点的前一个节点。 对上图的说明：分析双向链表的遍历，添加，修改，删除的操作思路： 遍历和单链表一样，只是可以向前，也可以向后查找。 添加(默认添加到双向链表的最后)。 先找到双向链表的最后这个节点 temp.next = newHeroNode newHeroNode.pre = temp 修改思路和原来的单向链表一样。 删除。 因为是双向链表，因此，我们可以实现自我删除某个节点。 直接找到要删除的这个节点，比如temp。 temp.pre.next = temp.next temp.next.pre = temp.pre 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public class DoubleLinkedListDemo &#123; public static void main(String[] args) &#123; // 先创建节点 HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨"); HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟"); HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星"); HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头"); // 创建一个双向链表 DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(hero1); doubleLinkedList.add(hero2); doubleLinkedList.add(hero3); doubleLinkedList.add(hero4); doubleLinkedList.list(); // 修改 HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙"); doubleLinkedList.update(newHeroNode); System.out.println("修改后的链表情况"); doubleLinkedList.list(); // 删除 doubleLinkedList.del(3); System.out.println("删除后的链表情况~~"); doubleLinkedList.list(); &#125;&#125;class DoubleLinkedList &#123; /** * 先初始化一个头节点, 头节点不要动, 不存放具体的数据 */ private HeroNode2 head = new HeroNode2(0, "", ""); /** * 返回头节点 */ public HeroNode2 getHead() &#123; return head; &#125; /** * 遍历双向链表的方法 * 显示链表[遍历] */ public void list() &#123; // 判断链表是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode2 temp = head.next; while (true) &#123; // 判断是否到链表最后 if (temp == null) &#123; break; &#125; // 输出节点的信息 System.out.println(temp); temp = temp.next; &#125; &#125; public void add(HeroNode2 heroNode) &#123; // 因为head节点不能动，因此我们需要一个辅助遍历 temp HeroNode2 temp = head; // 遍历链表，找到最后 while (true) &#123; // 找到链表的最后 if (temp.next == null) &#123; break; &#125; // 如果没有找到最后, 将将temp后移 temp = temp.next; &#125; // 当退出while 循环时，temp 就指向了链表的最后，形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; &#125; /** * 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样 * 只是节点类型改成HeroNode2 */ public void update(HeroNode2 newHeroNode) &#123; // 判断是否空 if (head.next == null) &#123; System.out.println("链表为空~"); return; &#125; // 找到需要修改的节点, 根据no 编号 // 定义一个辅助变量 HeroNode2 temp = head.next; // 表示是否找到该节点 boolean flag = false; while (true) &#123; if (temp == null) &#123; break; // 已经遍历完链表 &#125; if (temp.no == newHeroNode.no) &#123; // 找到 flag = true; break; &#125; temp = temp.next; &#125; // 根据flag 判断是否找到要修改的节点 if (flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; // 没有找到 System.out.printf("没有找到编号%d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; /** * 从双向链表中删除一个节点 * 1.对于双向链表，我们可以直接找到要删除的这个节点 * 2.找到后，自我删除即可 */ public void del(int no) &#123; // 判断当前链表是否为空 if (head.next == null) &#123; System.out.println("链表为空，无法删除"); return; &#125; // 辅助变量(指针) HeroNode2 temp = head.next; // 标志是否找到待删除节点的 boolean flag = false; while (true) &#123; if (temp == null) &#123; // 已经到链表的最后 break; &#125; if (temp.no == no) &#123; // 找到的待删除节点的前一个节点temp flag = true; break; &#125; // temp 后移，遍历 temp = temp.next; &#125; // 判断flag if (flag) &#123; // 找到，可以删除 temp.pre.next = temp.next; // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.next != null) &#123; temp.next.pre = temp.pre; &#125; &#125; else &#123; System.out.printf("要删除的%d 节点不存在\n", no); &#125; &#125;&#125;/** * 定义HeroNode2 ， 每个HeroNode 对象就是一个节点 */class HeroNode2 &#123; public int no; public String name; public String nickname; /** * 指向下一个节点, 默认为null */ public HeroNode2 next; /** * 指向前一个节点, 默认为null */ public HeroNode2 pre; public HeroNode2(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return "HeroNode2&#123;" + "no=" + no + ", name='" + name + '\'' + ", nickname='" + nickname + '\'' + '&#125;'; &#125;&#125; 约瑟夫问题Josephu 问题为：设编号为1，2，… n 的 n 个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1 开始报数，数到 m 的那个人出列，它的下一位又从1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由k 结点起从1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1 开始计数，直到最后一个结点从链表中删除算法结束。 单向环形链表 思路图解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class Josepfu &#123; public static void main(String[] args) &#123; CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); // 加入5 个小孩节点 circleSingleLinkedList.addBoy(5); circleSingleLinkedList.showBoy(); // 2-&gt;4-&gt;1-&gt;5-&gt;3 circleSingleLinkedList.countBoy(1, 2, 2); &#125;&#125;/** * 创建一个环形的单向链表 */class CircleSingleLinkedList &#123; /** * 创建一个first 节点,当前没有编号 */ private Boy first = null; /** * 添加小孩节点，构建成一个环形的链表 */ public void addBoy(int nums) &#123; // nums 做一个数据校验 if (nums &lt; 1) &#123; System.out.println("nums 的值不正确"); return; &#125; // 辅助指针，帮助构建环形链表 Boy curBoy = null; // 使用for 来创建我们的环形链表 for (int i = 1; i &lt;= nums; i++) &#123; // 根据编号，创建小孩节点 Boy boy = new Boy(i); // 如果是第一个小孩 if (i == 1) &#123; first = boy; // 构成环 first.next = boy; // 让curBoy 指向第一个小孩 curBoy = first; &#125; else &#123; curBoy.next = boy; boy.next = first; curBoy = boy; &#125; &#125; &#125; /** * 遍历当前的环形链表 */ public void showBoy() &#123; // 判断链表是否为空 if (first == null) &#123; System.out.println("没有任何小孩~~"); return; &#125; // 因为first 不能动，因此我们仍然使用一个辅助指针完成遍历 Boy curBoy = first; while (true) &#123; System.out.printf("小孩的编号%d \n", curBoy.no); if (curBoy.next == first) &#123; // 说明已经遍历完毕 break; &#125; // curBoy 后移 curBoy = curBoy.next; &#125; &#125; /** * 根据用户的输入，计算出小孩出圈的顺序 * * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少小孩在圈中 */ public void countBoy(int startNo, int countNum, int nums) &#123; // 先对数据进行校验 if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123; System.out.println("参数输入有误， 请重新输入"); return; &#125; // 创建要给辅助指针,帮助完成小孩出圈 // 创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 Boy helper = first; while (true) &#123; // 说明helper 指向最后小孩节点 if (helper.next == first) &#123; break; &#125; helper = helper.next; &#125; //小孩报数前，先让first 和helper 移动k - 1 次 for (int j = 0; j &lt; startNo - 1; j++) &#123; first = first.next; helper = helper.next; &#125; //当小孩报数时，让first 和helper 指针同时的移动m - 1 次, 然后出圈 //这里是一个循环操作，直到圈中只有一个节点 while (true) &#123; if (helper == first) &#123; //说明圈中只有一个节点 break; &#125; //让first 和helper 指针同时的移动countNum - 1 for (int j = 0; j &lt; countNum - 1; j++) &#123; first = first.next; helper = helper.next; &#125; //这时first 指向的节点，就是要出圈的小孩节点 System.out.printf("小孩%d 出圈\n", first.no); //这时将first 指向的小孩节点出圈 first = first.next; helper.next = first; &#125; System.out.printf("最后留在圈中的小孩编号%d \n", first.no); &#125;&#125;/** * 创建一个Boy 类，表示一个节点 */class Boy &#123; /** * 编号 */ public int no; /** * 指向下一个节点,默认null */ public Boy next; public Boy(int no) &#123; this.no = no; &#125; &#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（稀疏数组和队列）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%89.html</url>
    <content type="text"><![CDATA[稀疏数组问题导入编写的五子棋程序中，有存盘退出和续上盘的功能。 分析问题：因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据 -&gt; 稀疏数组。 基本介绍当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是： 记录数组一共有几行几列，有多少个不同的值。 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。 应用实例 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)。 把稀疏数组存盘，并且可以从新恢复原来的二维数组数。 思路分析 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class SparseArray &#123; public static void main(String[] args) &#123; // 创建一个原始的二维数组11 * 11 // 0: 表示没有棋子， 1 表示黑子2 表蓝子 int[][] chessArr1 = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; // 输出原始的二维数组 System.out.println("原始的二维数组~~"); for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.printf("%d\t", data); &#125; System.out.println(); &#125; // 将二维数组转稀疏数组的思路 // 1. 先遍历二维数组得到非0 数据的个数 int sum = 0; for (int i = 0; i &lt; chessArr1.length; i++) &#123; for (int j = 0; j &lt; chessArr1.length; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; // 2. 创建对应的稀疏数组 int[][] sparseArr = new int[sum + 1][3]; // 给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 遍历二维数组，将非0 的值存放到sparseArr 中 // count 用于记录是第几个非0 数据 int count = 0; for (int i = 0; i &lt; chessArr1.length; i++) &#123; for (int j = 0; j &lt; chessArr1.length; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; // 输出稀疏数组的形式 System.out.println(); System.out.println("得到稀疏数组为~~~~"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; System.out.println(); //将稀疏数组 --&gt; 恢复成原始的二维数组 /* * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr2 = int[11][11] * 2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可. * */ //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]]; //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给原始的二维数组即可 for (int i = 1; i &lt; sparseArr.length; i++) &#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; // 输出恢复后的二维数组 System.out.println(); System.out.println("恢复后的二维数组"); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.printf("%d\t", data); &#125; System.out.println(); &#125; &#125;&#125; 队列基本介绍 队列是一个有序列表，可以用数组或是链表来实现。 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出。 思路分析 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中maxSize 是该队列的最大容量。 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front 及rear 分别记录队列前后端的下标，front 会随着数据输出而改变，而rear 则是随着数据输入而改变，如图所示： 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤： 将尾指针往后移：rear+1 , 当front == rear 【队列空】。 若尾指针rear 小于队列的最大下标maxSize-1，则将数据存入rear 所指的数组元素中，否则无法存入数据。rear == maxSize - 1【队列满】。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class ArrayQueueDemo &#123; public static void main(String[] args) throws Exception &#123; // 创建一个队列 ArrayQueue queue = new ArrayQueue(3); // 接收用户输入 char key = ' '; Scanner scanner = new Scanner(System.in); boolean loop = true; // 输出一个菜单 while (loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); //接收一个字符 key = scanner.next().charAt(0); switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': // 取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e': // 退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;/** * 使用数组模拟队列-编写一个ArrayQueue 类 */class ArrayQueue &#123; /** * 表示数组的最大容量 */ private int maxSize; /** * 队列头 */ private int front; /** * 队列尾 */ private int rear; /** * 该数据用于存放数据, 模拟队列 */ private int[] arr; public ArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; // 指向队列头部，分析出front 是指向队列头的前一个位置. front = -1; // 指向队列尾，指向队列尾的数据(即就是队列最后一个数据) rear = -1; &#125; /** * 判断队列是否满 */ public boolean isFull() &#123; return rear == maxSize - 1; &#125; /** * 判断队列是否空 */ public boolean isEmpty() &#123; return rear == front; &#125; /** * 添加数据到队列 */ public void addQueue(int n) &#123; // 判断队列是否满 if (isFull()) &#123; System.out.println("队列满，不能加入数据~"); return; &#125; // 让rear 后移 rear++; arr[rear] = n; &#125; /** * 获取队列的数据, 出队列 */ public int getQueue() &#123; // 判断队列是否空 if (isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列空，不能取数据"); &#125; // front 后移 front++; return arr[front]; &#125; /** * 显示队列的所有数据 */ public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println("队列空的，没有数据~~"); return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf("arr[%d]=%d\n", i, arr[i]); &#125; &#125; /** * 显示队列的头数据， 注意不是取出数据 */ public int headQueue() &#123; // 判断 if (isEmpty()) &#123; throw new RuntimeException("队列空的，没有数据~~"); &#125; return arr[front + 1]; &#125;&#125; 问题分析与优化 目前数组使用一次就不能用， 没有达到复用的效果。 将这个数组使用算法，改进成一个环形的队列取模：%。 数组模拟环形队列对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可) 分析说明： rear 和 front 的含义同上面的示例相比都发生了变化，尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候，需要注意(rear + 1) % maxSize == front [满]，rear == front [空]。 思路分析： front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 front 的初始值 = 0。 rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置，因为希望空出一个空间做为约定，这样，数列总是有一个空间保持是空的。rear 的初始值 = 0。 当队列满时，条件是 (rear + 1) % maxSize == front 【满】。 对队列为空的条件， rear == front 空。 当我们这样分析， 队列中有效的数据的个数 (rear + maxSize - front) % maxSize // rear = 1 front = 0 。 我们就可以在原来的队列上修改得到，一个环形队列。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176public class CircleArrayQueueDemo &#123; public static void main(String[] args) throws Exception &#123; // 创建一个队列 CircleArray queue = new CircleArray(4); // 接收用户输入 char key = ' '; Scanner scanner = new Scanner(System.in); boolean loop = true; // 输出一个菜单 while (loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); //接收一个字符 key = scanner.next().charAt(0); switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': // 取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e': // 退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;class CircleArray &#123; /** * 表示数组的最大容量 */ private int maxSize; /** * 头索引 * 变量的含义做一个调整：front 就指向队列的第一个元素, 也就是说arr[front] 就是队列的第一个元素 * front 的初始值= 0 */ private int front = 0; /** * 尾索引 * 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定 */ private int rear; /** * 该数据用于存放数据, 模拟队列 */ private int[] arr; public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; /** * 判断队列是否满 */ public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; /** * 判断队列是否空 */ public boolean isEmpty() &#123; return rear == front; &#125; /** * 添加数据到队列 */ public void addQueue(int n) &#123; // 判断队列是否满 if (isFull()) &#123; System.out.println("队列满，不能加入数据~"); return; &#125; // 直接将数据加入 arr[rear] = n; // 将rear 后移, 这里必须考虑取模 rear = (rear + 1) % maxSize; &#125; /** * 获取队列的数据, 出队列 */ public int getQueue() &#123; // 判断队列是否空 if (isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列空，不能取数据"); &#125; // 这里需要分析出front 是指向队列的第一个元素 // 1. 先把front 对应的值保留到一个临时变量 // 2. front 的位置归零 // 3. 将front 后移, 考虑取模 // 4. 将临时保存的变量返回 int value = arr[front]; arr[front] = 0; front = (front + 1) % maxSize; return value; &#125; /** * 显示队列的所有数据 */ public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println("队列空的，没有数据~~"); return; &#125; // 思路：从front 开始遍历，遍历多少个元素 for (int i = 0; i &lt; front + size(); i++) &#123; System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]); &#125; &#125; /** * 求出当前队列有效数据的个数 */ public int size() &#123; // rear = 2 // front = 1 // maxSize = 3 return (rear + maxSize - front) % maxSize; &#125; /** * 显示队列的头数据， 注意不是取出数据 */ public int headQueue() &#123; // 判断 if (isEmpty()) &#123; throw new RuntimeException("队列空的，没有数据~~"); &#125; return arr[front]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（图）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%BE%EF%BC%89.html</url>
    <content type="text"><![CDATA[基本介绍为什么要有图 前面我们学了线性表和树。 线性表局限于一个直接前驱和一个直接后继的关系。 树也只能有一个直接前驱也就是父节点。 当我们需要表示多对多的关系时， 这里我们就用到了图。 举例说明图是一种数据结构，其中节点可以具有零个或多个相邻元素。两个节点之间的连接称为边。节点也可以称为顶点。如图： 常用概念 顶点( vertex ) 边( edge ) 路径 无向图 有向图 带权图 表示方式图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。 邻接矩阵邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。 邻接表 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失。 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成。 入门案例要求：代码实现如下图结构。 思路分析 存储顶点 String 使用 ArrayList 。 保存矩阵 int[][] edges 。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Graph &#123; /** * 存储顶点集合 */ private ArrayList&lt;String&gt; vertexList; /** * 存储图对应的邻结矩阵 */ private int[][] edges; /** * 表示边的数目 */ private int numOfEdges; public static void main(String[] args) &#123; // 测试图的创建 // 节点的个数 int n = 5; String vertices[] = &#123;"A", "B", "C", "D", "E"&#125;;// String vertices[] = &#123;"1", "2", "3", "4", "5", "6", "7", "8"&#125;; // 创建图对象 Graph graph = new Graph(n); // 循环的添加顶点 for (String vertex : vertices) &#123; graph.insertVertex(vertex); &#125; //添加边 //A-B A-C B-C B-D B-E graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.showGraph(); &#125; public Graph(int n) &#123; // 初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;&gt;(n); numOfEdges = 0; &#125; /** * 返回节点的个数 */ public int getNumOfVertex() &#123; return vertexList.size(); &#125; /** * 得到边的数目 */ public int getNumOfEdges() &#123; return numOfEdges; &#125; /** * 返回节点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C" */ public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; /** * 返回v1和v2的权值 */ public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 插入节点 */ public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * 显示图对应的矩阵 */ public void showGraph() &#123; for (int[] link : edges) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; /** * 添加边 * * @param v1 表示点的下标即使第几个顶点 "A"-"B" "A"-&gt;0 "B"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 权值 1/0 */ public void insertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125;&#125; 深度优先遍历图遍历介绍所谓图的遍历，即是对节点的访问。一个图有那么多个节点，如何遍历这些节点，需要特定策略，一般有两种访问策略： (1) 深度优先遍历，(2) 广度优先遍历。 基本思想图的深度优先搜索( Depth First Search ) 。 深度优先遍历，从初始访问节点出发，初始访问节点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始节点，访问它的第一个邻接节点， 可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一个邻接节点。 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个节点的所有邻接节点进行横向访问。 显然，深度优先搜索是一个递归的过程。 算法步骤 访问初始节点 v ，并标记节点 v 为已访问。 查找节点 v 的第一个邻接节点 w 。 若 w 存在，则继续执行4，如果 w 不存在，则回到第1 步，将从 v 的下一个节点继续。 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤123）。 查找节点 v 的 w 邻接节点的下一个邻接节点，转到步骤3。 代码实现12345678910111213141516171819202122232425262728293031323334//核心方法，全部代码放在后面/** * 深度优先遍历算法 * i 第一次就是 0 */private void dfs(boolean[] isVisited, int i) &#123; // 首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + "-&gt;"); // 将结点设置为已经访问 isVisited[i] = true; // 查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while (w != -1) &#123; // 说明有 if (!isVisited[w]) &#123; dfs(isVisited, w); &#125; // 如果w结点已经被访问过 w = getNextNeighbor(i, w); &#125;&#125;/** * 对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs */public void dfs() &#123; isVisited = new boolean[vertexList.size()]; // 遍历所有的结点，进行dfs[回溯] for (int i = 0; i &lt; getNumOfVertex(); i++) &#123; if (!isVisited[i]) &#123; dfs(isVisited, i); &#125; &#125;&#125; 广度优先遍历基本思想 图的广度优先搜索( Broad First Search ) 。 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。 算法步骤 访问初始结点 v 并标记结点 v 为已访问。 结点 v 入队列。 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点 u 。 查找结点 u 的第一个邻接结点 w 。 若结点 u 的邻接结点w 不存在，则转到步骤3；否则循环执行以下三个步骤： 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 结点 w 入队列。 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w ，转到步骤6。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//核心方法，全部代码放在后面/** * 对一个节点进行广度优先遍历的方法 */private void bfs(boolean[] isVisited, int i) &#123; // 表示队列的头节点对应下标 int u; // 邻接节点下标w int w; // 队列，记录节点访问的顺序 LinkedList queue = new LinkedList(); // 访问节点，输出节点信息 System.out.print(getValueByIndex(i) + "=&gt;"); // 标记为已访问 isVisited[i] = true; // 将节点加入队列 queue.addLast(i); while (!queue.isEmpty()) &#123; // 取出队列的头结点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) &#123; // 找到 // 是否访问过 if (!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + "=&gt;"); // 标记已经访问 isVisited[w] = true; // 入队 queue.addLast(w); &#125; // 以u为前驱点，找w后面的下一个邻结点 // 体现出我们的广度优先 w = getNextNeighbor(u, w); &#125; &#125;&#125;/** * 遍历所有的结点，都进行广度优先搜索 */public void bfs() &#123; isVisited = new boolean[vertexList.size()]; for (int i = 0; i &lt; getNumOfVertex(); i++) &#123; if (!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125;&#125; 代码汇总123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230public class Graph &#123; /** * 存储顶点集合 */ private ArrayList&lt;String&gt; vertexList; /** * 存储图对应的邻结矩阵 */ private int[][] edges; /** * 表示边的数目 */ private int numOfEdges; /** * 定义给数组boolean[], 记录某个节点是否被访问 */ private boolean[] isVisited; public static void main(String[] args) &#123; // 测试图的创建 String vertices[] = &#123;"A", "B", "C", "D", "E"&#125;; // 节点的个数 int n = vertices.length; // 创建图对象 Graph graph = new Graph(n); // 循环的添加顶点 for (String vertex : vertices) &#123; graph.insertVertex(vertex); &#125; //添加边 //A-B A-C B-C B-D B-E graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.showGraph(); System.out.println("深度优先遍历"); graph.dfs(); System.out.println(); System.out.println("广度优先遍历"); graph.bfs(); &#125; public Graph(int n) &#123; // 初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;&gt;(n); numOfEdges = 0; &#125; /** * 深度优先遍历算法 * i 第一次就是 0 */ private void dfs(boolean[] isVisited, int i) &#123; // 首先我们访问该节点,输出 System.out.print(getValueByIndex(i) + "=&gt;"); // 将节点设置为已经访问 isVisited[i] = true; // 查找节点i的第一个邻接节点w int w = getFirstNeighbor(i); while (w != -1) &#123; // 说明有 if (!isVisited[w]) &#123; dfs(isVisited, w); &#125; // 如果w节点已经被访问过 w = getNextNeighbor(i, w); &#125; &#125; /** * 对dfs 进行一个重载, 遍历我们所有的节点，并进行 dfs */ public void dfs() &#123; isVisited = new boolean[vertexList.size()]; // 遍历所有的节点，进行dfs[回溯] for (int i = 0; i &lt; getNumOfVertex(); i++) &#123; if (!isVisited[i]) &#123; dfs(isVisited, i); &#125; &#125; &#125; /** * 对一个节点进行广度优先遍历的方法 */ private void bfs(boolean[] isVisited, int i) &#123; // 表示队列的头节点对应下标 int u; // 邻接节点下标w int w; // 队列，记录节点访问的顺序 LinkedList queue = new LinkedList(); // 访问节点，输出节点信息 System.out.print(getValueByIndex(i) + "=&gt;"); // 标记为已访问 isVisited[i] = true; // 将节点加入队列 queue.addLast(i); while (!queue.isEmpty()) &#123; // 取出队列的头结点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) &#123; // 找到 // 是否访问过 if (!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + "=&gt;"); // 标记已经访问 isVisited[w] = true; // 入队 queue.addLast(w); &#125; // 以u为前驱点，找w后面的下一个邻结点 // 体现出我们的广度优先 w = getNextNeighbor(u, w); &#125; &#125; &#125; /** * 遍历所有的结点，都进行广度优先搜索 */ public void bfs() &#123; isVisited = new boolean[vertexList.size()]; for (int i = 0; i &lt; getNumOfVertex(); i++) &#123; if (!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125; &#125; /** * 得到第一个邻接节点的下标w * * @param index 当前节点的下标 * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) &#123; for (int j = 0; j &lt; vertexList.size(); j++) &#123; if (edges[index][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; /** * 根据当前节点的下标和第一个邻接节点的下标来获取下一个邻接节点的下标 */ public int getNextNeighbor(int v1, int v2) &#123; for (int j = v2 + 1; j &lt; vertexList.size(); j++) &#123; if (edges[v1][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; /** * 返回节点的个数 */ public int getNumOfVertex() &#123; return vertexList.size(); &#125; /** * 得到边的数目 */ public int getNumOfEdges() &#123; return numOfEdges; &#125; /** * 返回节点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C" */ public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; /** * 返回v1和v2的权值 */ public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 插入节点 */ public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * 显示图对应的矩阵 */ public void showGraph() &#123; for (int[] link : edges) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; /** * 添加边 * * @param v1 表示点的下标即使第几个顶点 "A"-"B" "A"-&gt;0 "B"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 权值 1/0 */ public void insertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125;&#125; 深度优先VS 广度优先]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（树结构进阶）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%91%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%EF%BC%89.html</url>
    <content type="text"><![CDATA[赫夫曼树基本介绍 给定 n 个权值作为 n 个叶子节点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 赫夫曼树是带权路径长度最短的树，权值较大的节点离根较近。 概念说明 路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或孙子节点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L 层节点的路径长度为L-1。 节点的权及带权路径长度：若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权。节点的带权路径长度为：从根节点到该节点之间的路径长度与该节点的权的乘积。 树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的节点离根节点越近的二叉树才是最优二叉树。 WPL 最小的就是赫夫曼树。 思路分析给定一个数列{13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树。 步骤： 从小到大进行排序, 将每一个数据，每个数据都是一个节点， 每个节点可以看成是一颗最简单的二叉树。 取出根节点权值最小的两颗二叉树。 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。 再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class HuffmanTree &#123; public static void main(String[] args) &#123; int arr[] = &#123;13, 7, 8, 3, 29, 6, 1&#125;; Node root = createHuffmanTree(arr); preOrder(root); &#125; /** * 创建赫夫曼树 * * @param arr 需要创建成哈夫曼树的数组 * @return 创建好后的赫夫曼树的root 节点 */ public static Node createHuffmanTree(int[] arr) &#123; // 第一步为了操作方便 // 1. 遍历arr 数组 // 2. 将arr的每个元素构成成一个Node // 3. 将Node放入到ArrayList 中 List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (int value : arr) &#123; nodes.add(new Node(value)); &#125; // 我们处理的过程是一个循环的过程 while (nodes.size() &gt; 1) &#123; // 排序从小到大 Collections.sort(nodes); // 取出根节点权值最小的两颗二叉树 // (1) 取出权值最小的节点（二叉树） Node leftNode = nodes.get(0); // (2) 取出权值第二小的节点（二叉树） Node rightNode = nodes.get(1); // (3)构建一颗新的二叉树 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; // (4)从ArrayList 删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); // (5)将parent加入到nodes nodes.add(parent); &#125; //返回哈夫曼树的root节点 return nodes.get(0); &#125; /** * 前序遍历 * * @param root root节点 */ public static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("是空树，不能遍历~~"); &#125; &#125;&#125;/** * 创建节点类 * 为了让Node 对象持续排序Collections 集合排序,让Node 实现Comparable 接口 */class Node implements Comparable&lt;Node&gt; &#123; /** * 节点权值 */ int value; /** * 指向左子节点 */ Node left; /** * 指向右子节点 */ Node right; public Node(int value) &#123; this.value = value; &#125; /** * 前序遍历 */ public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public int compareTo(Node o) &#123; // 表示从小到大排序 return this.value - o.value; &#125; @Override public String toString() &#123; return "Node&#123;" + "value=" + value + '&#125;'; &#125;&#125; 赫夫曼编码基本介绍 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法。 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间。 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于1952 年提出一种编码方法，称之为最佳编码。 原理剖析 通信领域中信息的处理方式1-定长编码 i like like like java do you like a java // 共40个字符(包括空格) 105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 //对应Ascii码 01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制 按照二进制来传递信息，总的长度是 359 (包括空格) 在线转码工具 ：https://www.mokuge.com/tool/asciito16/ 通信领域中信息的处理方式2-变长编码 i like like like java do you like a java // 共40个字符(包括空格) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 0= , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如空格出现了9 次， 编码为0 ,其它依次类推 按照上面给各个字符规定的编码，则我们在传输 “i like like like java do you like a java” 数据时，编码就是 10010110100… 字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码 通信领域中信息的处理方式3-赫夫曼编码 i like like like java do you like a java // 共40个字符(包括空格) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 步骤： 从小到大进行排序, 将每一个数据，每个数据都是一个节点， 每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 根据赫夫曼树，给各个字符,规定编码(前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下: 123o: 1000 u: 10010 d: 100110 y: 100111 i: 101a : 110 k: 1110 e: 1111 j: 0000 v: 0001l: 001 : 01 按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为(注意这里我们使用的无损压缩)1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 。通过赫夫曼编码处理长度为133 原来长度是359 , 压缩了(359-133) / 359 = 62.9%。此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。赫夫曼编码是无损处理方案。 注意事项 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为: 最佳实践-数据压缩(创建赫夫曼树)将给出的一段文本，比如”i like like like java do you like a java” ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理， 形式如“1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class HuffmanCode &#123; public static void main(String[] args) &#123; String content = "i like like like java do you like a java"; byte[] bytes = content.getBytes(); // 1.统计字节数组，生成node列表 List&lt;HuffmanNode&gt; nodes = getNode(bytes); // 2.创建赫夫曼树 HuffmanNode root = createHuffmanTree(nodes); &#125; /** * 前序遍历 */ private static void preOrder(HuffmanNode root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("赫夫曼树为空"); &#125; &#125; private static List&lt;HuffmanNode&gt; getNode(byte[] bytes) &#123; // 1.创建一个ArrayList List&lt;HuffmanNode&gt; nodes = new ArrayList&lt;&gt;(); // 遍历bytes，统计每一个byte出现的次数 -&gt; map[key,value] Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; counts.merge(b, 1, (a, b1) -&gt; a + b1); &#125; // 把每一个键值对转成一个Node对象，并加入到Nodes集合 // 遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new HuffmanNode(entry.getKey(), entry.getValue())); &#125; return nodes; &#125; /** * 通过List创建赫夫曼树 * * @param nodes nodes */ private static HuffmanNode createHuffmanTree(List&lt;HuffmanNode&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; // 排序从小到大 Collections.sort(nodes); // 取出第一棵最小的二叉树 HuffmanNode leftNode = nodes.get(0); // 取出第二棵最小的二叉树 HuffmanNode rightNode = nodes.get(1); // 创建一棵新的二叉树，它的根节点没有data，只有权值 HuffmanNode parent = new HuffmanNode(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; //将已经处理的两棵二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树加入到nodes nodes.add(parent); &#125; // nodes 最后的节点，就是赫夫曼树的根节点 return nodes.get(0); &#125;&#125;/** * 创建节点类，带数据和权值 */class HuffmanNode implements Comparable&lt;HuffmanNode&gt; &#123; /** * 存放数据（字符）本身，比如 'a' =&gt; 97 ' ' =&gt; 32 */ Byte data; /** * 数值，表示字符出现的次数 */ int weight; /** * 指向左子节点 */ HuffmanNode left; /** * 指向右子节点 */ HuffmanNode right; public HuffmanNode(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; /** * 前序遍历 */ public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public int compareTo(HuffmanNode o) &#123; // 表示从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return "HuffmanNode&#123;" + "data=" + data + ", weight=" + weight + '&#125;'; &#125;&#125; 最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据)我们已经生成了赫夫曼树, 下面我们继续完成任务 生成赫夫曼树对应的赫夫曼编码, 如下表: 1=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011 使用赫夫曼编码来生成赫夫曼编码数据,即按照上面的赫夫曼编码，将”i like like like java do you like a java”字符串生成对应的编码数据, 形式如下： 1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244public class HuffmanCode &#123; public static void main(String[] args) &#123; String content = "i like like like java do you like a java"; byte[] contentBytes = content.getBytes(); byte[] huffmanCodesBytes = huffmanZip(contentBytes); System.out.println("压缩后的结果是:" + Arrays.toString(huffmanCodesBytes) + " 长度= " + huffmanCodesBytes.length); &#125; /** * 封装赫夫曼编码方法 * * @param bytes 原始的字符串对应的字节数组 * @return 是经过 赫夫曼编码处理后的字节数组(压缩后的数组) */ private static byte[] huffmanZip(byte[] bytes) &#123; // 1.统计字节数组，生成node列表 List&lt;HuffmanNode&gt; nodes = getNode(bytes); // 2.创建赫夫曼树 HuffmanNode root = createHuffmanTree(nodes); // 3.生成赫夫曼树对应的赫夫曼编码 Map&lt;Byte, String&gt; huffmanCodes = getCodes(root); // 4.使用赫夫曼编码来生成赫夫曼编码数据 return zip(bytes, huffmanCodes); &#125; /** * 生成赫夫曼树对应的赫夫曼编码 * 思路: * 2.1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 * 生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125; */ static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); /** * 2.2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子节点的路径 */ static StringBuilder stringBuilder = new StringBuilder(); /** * 将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[] * * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = "i like like like java do you like a java"; =&gt; byte[] contentBytes = content.getBytes(); * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; // 1.利用huffmanCodes 将bytes转成赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; // 将 "1010100010111111110..." 转成 byte[] // 统计返回 byte[] huffmanCodeBytes 长度// int len;// if(stringBuilder.length() % 8 == 0) &#123;// len = stringBuilder.length() / 8;// &#125; else &#123;// len = stringBuilder.length() / 8 + 1;// &#125; int len = (stringBuilder.length() + 7) / 8; // 创建存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; // 记录是第几个byte int index = 0; // 因为是每8位对应一个byte,所以步长 +8 for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; // 不够8位 if (i + 8 &gt; stringBuilder.length()) &#123; strByte = stringBuilder.substring(i); &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); &#125; // 将strByte 转成一个byte,放入到 huffmanCodeBytes huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; return huffmanCodeBytes; &#125; /** * 将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到huffmanCodes集合 * * @param node 传入节点 * @param code 路径：左子节点是 0, 右子节点 1 * @param stringBuilder 用于拼接路径 */ private static void getCodes(HuffmanNode node, String code, StringBuilder stringBuilder) &#123; StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); // 将code 加入到 stringBuilder2 stringBuilder2.append(code); // 如果node == null不处理 if (node != null) &#123; // 判断当前node 是叶子节点还是非叶子节点 if (node.data == null) &#123; // 非叶子节点 // 递归处理 // 向左递归 getCodes(node.left, "0", stringBuilder2); // 向右递归 getCodes(node.right, "1", stringBuilder2); &#125; else &#123; // 说明是一个叶子节点 // 就表示找到某个叶子节点的最后 huffmanCodes.put(node.data, stringBuilder2.toString()); &#125; &#125; &#125; private static Map&lt;Byte, String&gt; getCodes(HuffmanNode root) &#123; if (root == null) &#123; return null; &#125; //处理root的左子树 getCodes(root.left, "0", stringBuilder); //处理root的右子树 getCodes(root.right, "1", stringBuilder); return huffmanCodes; &#125; /** * 前序遍历 */ private static void preOrder(HuffmanNode root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("赫夫曼树为空"); &#125; &#125; private static List&lt;HuffmanNode&gt; getNode(byte[] bytes) &#123; // 1.创建一个ArrayList List&lt;HuffmanNode&gt; nodes = new ArrayList&lt;&gt;(); // 遍历bytes，统计每一个byte出现的次数 -&gt; map[key,value] Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; counts.merge(b, 1, (a, b1) -&gt; a + b1); &#125; // 把每一个键值对转成一个Node对象，并加入到Nodes集合 // 遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new HuffmanNode(entry.getKey(), entry.getValue())); &#125; return nodes; &#125; /** * 通过List创建赫夫曼树 * * @param nodes nodes */ private static HuffmanNode createHuffmanTree(List&lt;HuffmanNode&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; // 排序从小到大 Collections.sort(nodes); // 取出第一棵最小的二叉树 HuffmanNode leftNode = nodes.get(0); // 取出第二棵最小的二叉树 HuffmanNode rightNode = nodes.get(1); // 创建一棵新的二叉树，它的根节点没有data，只有权值 HuffmanNode parent = new HuffmanNode(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; //将已经处理的两棵二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树加入到nodes nodes.add(parent); &#125; // nodes 最后的节点，就是赫夫曼树的根节点 return nodes.get(0); &#125;&#125;/** * 创建节点类，带数据和权值 */class HuffmanNode implements Comparable&lt;HuffmanNode&gt; &#123; /** * 存放数据（字符）本身，比如 'a' =&gt; 97 ' ' =&gt; 32 */ Byte data; /** * 数值，表示字符出现的次数 */ int weight; /** * 指向左子节点 */ HuffmanNode left; /** * 指向右子节点 */ HuffmanNode right; public HuffmanNode(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; /** * 前序遍历 */ public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public int compareTo(HuffmanNode o) &#123; // 表示从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return "HuffmanNode&#123;" + "data=" + data + ", weight=" + weight + '&#125;'; &#125;&#125; 最佳实践-数据解压(使用赫夫曼编码解码)使用赫夫曼编码来解码数据，具体要求是 前面我们得到了赫夫曼编码和对应的编码 byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] 现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串”i like like like java do you like a java”。 思路：解码过程，就是编码的一个逆向操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 完成数据的解压// 思路// 1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]// 重写先转成 赫夫曼编码对应的二进制的字符串 "1010100010111..."// 2. 赫夫曼编码对应的二进制的字符串 "1010100010111..." =&gt; 对照 赫夫曼编码 =&gt; "i like like like java do you like a java"/** * 将一个byte 转成一个二进制的字符串 * * @param b 传入的byte * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位 * @return 是该b对应的二进制的字符串（注意是按补码返回） */private static String byteToBitString(boolean flag, byte b) &#123; // 使用变量保存b // 将b转成int int temp = b; // 如果是正数我们还存在补高位 if (flag) &#123; // 按位与 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001 temp |= 256; &#125; // 返回的是temp对应的二进制的补码 String str = Integer.toBinaryString(temp); if (flag) &#123; return str.substring(str.length() - 8); &#125; else &#123; return str; &#125;&#125;/** * 编写一个方法，完成对压缩数据的解码 * * @param huffmanCodes 赫夫曼编码表 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; // 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111... StringBuilder stringBuilder = new StringBuilder(); // 将byte数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; // 判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; // 把字符串安装指定的赫夫曼编码进行解码 // 把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; // 创建要给集合，存放byte List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); // i可以理解成就是索引,扫描 stringBuilder for (int i = 0; i &lt; stringBuilder.length(); ) &#123; // 小的计数器 int count = 1; boolean flag = true; Byte b = null; while (flag) &#123; // 1010100010111... // 递增的取出 key 1 // i 不动，让count移动，指定匹配到一个字符 String key = stringBuilder.substring(i, i + count); b = map.get(key); // 说明没有匹配到 if (b == null) &#123; count++; &#125; else &#123; // 匹配到 flag = false; &#125; &#125; list.add(b); // i直接移动到 count i += count; &#125; // 当for循环结束后，我们list中就存放了所有的字符 "i like like like java do you like a java" // 把list 中的数据放入到byte[] 并返回 byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i] = list.get(i); &#125; return b;&#125;/** * 测试main方法 */public static void main(String[] args) &#123; String content = "i like like like java do you like a java"; byte[] contentBytes = content.getBytes(); byte[] huffmanCodesBytes = huffmanZip(contentBytes); System.out.println("压缩后的结果是:" + Arrays.toString(huffmanCodesBytes) + " 长度= " + huffmanCodesBytes.length); List&lt;HuffmanNode&gt; nodes = getNode(contentBytes); HuffmanNode root = createHuffmanTree(nodes); Map&lt;Byte, String&gt; huffmanCodes = getCodes(root); byte[] bytes = decode(huffmanCodes, huffmanCodesBytes); System.out.println(new String(bytes));&#125; 最佳实践-文件压缩下面我们来完成对文件的压缩和解压， 具体要求：给一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。思路：读取文件-&gt; 得到赫夫曼编码表-&gt; 完成压缩。 代码实现： 123456789101112131415161718192021222324252627/** * 将一个文件进行压缩 * * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩后将压缩文件放到哪个目录 */public static void zipFile(String srcFile, String dstFile) &#123; try (FileInputStream is = new FileInputStream(srcFile); OutputStream os = new FileOutputStream(dstFile); ObjectOutputStream oos = new ObjectOutputStream(os); ) &#123; // 创建一个和源文件大小一样的byte[] byte[] b = new byte[is.available()]; // 读取文件 is.read(b); // 直接对源文件压缩 byte[] huffmanBytes = huffmanZip(b); // 把赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); //这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码 写入压缩文件 oos.writeObject(huffmanCodes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 最佳实践-文件解压(文件恢复)具体要求：将前面压缩的文件，重新恢复成原来的文件。思路：读取压缩文件(数据和赫夫曼编码表) -&gt; 完成解压(文件恢复) 代码实现： 12345678910111213141516171819202122232425/** * 对压缩文件的解压 * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */public static void unZipFile(String zipFile, String dstFile) &#123; try (FileInputStream is = new FileInputStream(zipFile); OutputStream os = new FileOutputStream(dstFile); // 创建一个和is关联的对象输入流 ObjectInputStream ois = new ObjectInputStream(is); ) &#123; // 读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); // 读取赫夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); // 解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); // 写数据到 dstFile 文件 os.write(bytes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 代码汇总，把前面所有的方法放在一起 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400public class HuffmanCode &#123; public static void main(String[] args) &#123;// String content = "i like like like java do you like a java";// byte[] contentBytes = content.getBytes();// byte[] huffmanCodesBytes = huffmanZip(contentBytes);// System.out.println("压缩后的结果是:" + Arrays.toString(huffmanCodesBytes) + " 长度= " + huffmanCodesBytes.length);//// List&lt;HuffmanNode&gt; nodes = getNode(contentBytes);// HuffmanNode root = createHuffmanTree(nodes);// Map&lt;Byte, String&gt; huffmanCodes = getCodes(root);// byte[] bytes = decode(huffmanCodes, huffmanCodesBytes);// System.out.println(new String(bytes)); String srcFile = "e:/aaa.png"; String destFile = "e:/dest.zip"; zipFile(srcFile, destFile); unZipFile(destFile, "e:/bbb.png"); &#125; /** * 对压缩文件的解压 * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile, String dstFile) &#123; try (FileInputStream is = new FileInputStream(zipFile); OutputStream os = new FileOutputStream(dstFile); // 创建一个和is关联的对象输入流 ObjectInputStream ois = new ObjectInputStream(is); ) &#123; // 读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); // 读取赫夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); // 解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); // 写数据到 dstFile 文件 os.write(bytes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 将一个文件进行压缩 * * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩后将压缩文件放到哪个目录 */ public static void zipFile(String srcFile, String dstFile) &#123; try (FileInputStream is = new FileInputStream(srcFile); OutputStream os = new FileOutputStream(dstFile); ObjectOutputStream oos = new ObjectOutputStream(os); ) &#123; // 创建一个和源文件大小一样的byte[] byte[] b = new byte[is.available()]; // 读取文件 is.read(b); // 直接对源文件压缩 byte[] huffmanBytes = huffmanZip(b); // 把赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); //这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码 写入压缩文件 oos.writeObject(huffmanCodes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 封装赫夫曼编码方法 * * @param bytes 原始的字符串对应的字节数组 * @return 是经过 赫夫曼编码处理后的字节数组(压缩后的数组) */ private static byte[] huffmanZip(byte[] bytes) &#123; // 1.统计字节数组，生成node列表 List&lt;HuffmanNode&gt; nodes = getNode(bytes); // 2.创建赫夫曼树 HuffmanNode root = createHuffmanTree(nodes); // 3.生成赫夫曼树对应的赫夫曼编码 Map&lt;Byte, String&gt; huffmanCodes = getCodes(root); // 4.使用赫夫曼编码来生成赫夫曼编码数据 return zip(bytes, huffmanCodes); &#125; /** * 生成赫夫曼树对应的赫夫曼编码 * 思路: * 2.1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 * 生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125; */ static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); /** * 2.2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子节点的路径 */ static StringBuilder stringBuilder = new StringBuilder(); /** * 将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[] * * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = "i like like like java do you like a java"; =&gt; byte[] contentBytes = content.getBytes(); * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; // 1.利用huffmanCodes 将bytes转成赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; // 将 "1010100010111111110..." 转成 byte[] // 统计返回 byte[] huffmanCodeBytes 长度// int len;// if(stringBuilder.length() % 8 == 0) &#123;// len = stringBuilder.length() / 8;// &#125; else &#123;// len = stringBuilder.length() / 8 + 1;// &#125; int len = (stringBuilder.length() + 7) / 8; // 创建存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; // 记录是第几个byte int index = 0; // 因为是每8位对应一个byte,所以步长 +8 for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; // 不够8位 if (i + 8 &gt; stringBuilder.length()) &#123; strByte = stringBuilder.substring(i); &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); &#125; // 将strByte 转成一个byte,放入到 huffmanCodeBytes huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; return huffmanCodeBytes; &#125; /** * 编写一个方法，完成对压缩数据的解码 * * @param huffmanCodes 赫夫曼编码表 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; // 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111... StringBuilder stringBuilder = new StringBuilder(); // 将byte数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; // 判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; // 把字符串安装指定的赫夫曼编码进行解码 // 把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; // 创建要给集合，存放byte List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); // i可以理解成就是索引,扫描 stringBuilder for (int i = 0; i &lt; stringBuilder.length(); ) &#123; // 小的计数器 int count = 1; boolean flag = true; Byte b = null; while (flag) &#123; // 1010100010111... // 递增的取出 key 1 // i 不动，让count移动，指定匹配到一个字符 String key = stringBuilder.substring(i, i + count); b = map.get(key); // 说明没有匹配到 if (b == null) &#123; count++; &#125; else &#123; // 匹配到 flag = false; &#125; &#125; list.add(b); // i直接移动到 count i += count; &#125; // 当for循环结束后，我们list中就存放了所有的字符 "i like like like java do you like a java" // 把list 中的数据放入到byte[] 并返回 byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i] = list.get(i); &#125; return b; &#125; // 完成数据的解压 // 思路 // 1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] // 重写先转成 赫夫曼编码对应的二进制的字符串 "1010100010111..." // 2. 赫夫曼编码对应的二进制的字符串 "1010100010111..." =&gt; 对照 赫夫曼编码 =&gt; "i like like like java do you like a java" /** * 将一个byte 转成一个二进制的字符串 * * @param b 传入的byte * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位 * @return 是该b对应的二进制的字符串（注意是按补码返回） */ private static String byteToBitString(boolean flag, byte b) &#123; // 使用变量保存b // 将b转成int int temp = b; // 如果是正数我们还存在补高位 if (flag) &#123; // 按位与 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001 temp |= 256; &#125; // 返回的是temp对应的二进制的补码 String str = Integer.toBinaryString(temp); if (flag) &#123; return str.substring(str.length() - 8); &#125; else &#123; return str; &#125; &#125; /** * 将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到huffmanCodes集合 * * @param node 传入节点 * @param code 路径：左子节点是 0, 右子节点 1 * @param stringBuilder 用于拼接路径 */ private static void getCodes(HuffmanNode node, String code, StringBuilder stringBuilder) &#123; StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); // 将code 加入到 stringBuilder2 stringBuilder2.append(code); // 如果node == null不处理 if (node != null) &#123; // 判断当前node 是叶子节点还是非叶子节点 if (node.data == null) &#123; // 非叶子节点 // 递归处理 // 向左递归 getCodes(node.left, "0", stringBuilder2); // 向右递归 getCodes(node.right, "1", stringBuilder2); &#125; else &#123; // 说明是一个叶子节点 // 就表示找到某个叶子节点的最后 huffmanCodes.put(node.data, stringBuilder2.toString()); &#125; &#125; &#125; private static Map&lt;Byte, String&gt; getCodes(HuffmanNode root) &#123; if (root == null) &#123; return null; &#125; //处理root的左子树 getCodes(root.left, "0", stringBuilder); //处理root的右子树 getCodes(root.right, "1", stringBuilder); return huffmanCodes; &#125; /** * 前序遍历 */ private static void preOrder(HuffmanNode root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("赫夫曼树为空"); &#125; &#125; private static List&lt;HuffmanNode&gt; getNode(byte[] bytes) &#123; // 1.创建一个ArrayList List&lt;HuffmanNode&gt; nodes = new ArrayList&lt;&gt;(); // 遍历bytes，统计每一个byte出现的次数 -&gt; map[key,value] Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; counts.merge(b, 1, (a, b1) -&gt; a + b1); &#125; // 把每一个键值对转成一个Node对象，并加入到Nodes集合 // 遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new HuffmanNode(entry.getKey(), entry.getValue())); &#125; return nodes; &#125; /** * 通过List创建赫夫曼树 * * @param nodes nodes */ private static HuffmanNode createHuffmanTree(List&lt;HuffmanNode&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; // 排序从小到大 Collections.sort(nodes); // 取出第一棵最小的二叉树 HuffmanNode leftNode = nodes.get(0); // 取出第二棵最小的二叉树 HuffmanNode rightNode = nodes.get(1); // 创建一棵新的二叉树，它的根节点没有data，只有权值 HuffmanNode parent = new HuffmanNode(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; //将已经处理的两棵二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树加入到nodes nodes.add(parent); &#125; // nodes 最后的节点，就是赫夫曼树的根节点 return nodes.get(0); &#125;&#125;/** * 创建节点类，带数据和权值 */class HuffmanNode implements Comparable&lt;HuffmanNode&gt; &#123; /** * 存放数据（字符）本身，比如 'a' =&gt; 97 ' ' =&gt; 32 */ Byte data; /** * 数值，表示字符出现的次数 */ int weight; /** * 指向左子节点 */ HuffmanNode left; /** * 指向右子节点 */ HuffmanNode right; public HuffmanNode(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; /** * 前序遍历 */ public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public int compareTo(HuffmanNode o) &#123; // 表示从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return "HuffmanNode&#123;" + "data=" + data + ", weight=" + weight + '&#125;'; &#125;&#125; 赫夫曼编码压缩文件注意事项 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件[举例压一个.ppt]。 赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml 文件]。 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显。 二叉排序树基本介绍先看一个需求。给你一个数列(7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。 解决方案分析： 使用数组 数组未排序， 优点：直接在数组尾添加，速度快。缺点：查找速度慢。 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。 使用链式存储-链表 不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。 使用二叉排序树 二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点。 比如针对前面的数据(7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为： 树创建和遍历一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为Array(7, 3, 10, 12, 5, 1, 9)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class BinarySortTreeDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;7, 3, 10, 12, 5, 1, 9&#125;; BinarySortTree binarySortTree = new BinarySortTree(); // 循环的添加节点到二叉排序树 for (int i = 0; i &lt; arr.length; i++) &#123; binarySortTree.add(new BinarySortNode(arr[i])); &#125; // 中序遍历二叉排序树 System.out.println("中序遍历二叉排序树~"); // 1, 3, 5, 7, 9, 10, 12 binarySortTree.infixOrder(); &#125;&#125;/** * 创建二叉排序树 */class BinarySortTree &#123; private BinarySortNode root; /** * 添加节点的方法 * * @param node node */ public void add(BinarySortNode node) &#123; // 如果root为空则直接让root指向node if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("二叉排序树为空，不能遍历"); &#125; &#125;&#125;/** * 创建Node节点 */class BinarySortNode &#123; int value; BinarySortNode left; BinarySortNode right; public BinarySortNode(int value) &#123; this.value = value; &#125; /** * 添加节点的方法 * 递归的形式添加节点，注意需要满足二叉排序树的要求 */ public void add(BinarySortNode node) &#123; if (node == null) &#123; return; &#125; // 判断传入的节点的值，和当前子树的根节点的值关系 if (node.value &lt; this.value) &#123; // 如果当前节点左子节点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的节点的值大于当前节点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; @Override public String toString() &#123; return "BinarySortNode&#123;" + "value=" + value + '&#125;'; &#125;&#125; 树的删除二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 删除叶子节点(比如：2, 5, 9, 12) 删除只有一颗子树的节点(比如：1) 删除有两颗子树的节点. (比如：7, 3，10 ) 思路分析1234567891011121314151617181920212223242526272829303132333435第一种情况:删除叶子节点(比如：2, 5, 9, 12)思路(1) 需求先去找到要删除的节点 targetNode(2) 找到 targetNode 的父节点 parent(3) 确定 targetNode 是 parent 的左子节点还是右子节点(4) 根据前面的情况来对应删除左子节点parent.left = null右子节点parent.right = null;第二种情况: 删除只有一颗子树的节点比如1思路(1) 需求先去找到要删除的节点 targetNode(2) 找到 targetNode 的父节点 parent(3) 确定 targetNode 的子节点是左子节点还是右子节点(4) targetNode 是 parent 的左子节点还是右子节点(5) 如果targetNode 有左子节点5. 1 如果 targetNode 是 parent 的左子节点parent.left = targetNode.left;5.2 如果 targetNode 是 parent 的右子节点parent.right = targetNode.left;(6) 如果 targetNode 有右子节点6.1 如果 targetNode 是 parent 的左子节点parent.left = targetNode.right;6.2 如果 targetNode 是 parent 的右子节点parent.right = targetNode.right第三种情况： 删除有两颗子树的节点. (比如：7, 3，10 ) 思路(1) 需求先去找到要删除的节点 targetNode(2) 找到 targetNode 的父节点 parent(3) 从 targetNode 的右子树找到最小的节点(4) 用一个临时变量，将最小节点的值保存temp = 11(5) 删除该最小节点(6) targetNode.value = temp 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294public class BinarySortTreeDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;; BinarySortTree binarySortTree = new BinarySortTree(); // 循环的添加节点到二叉排序树 for (int i = 0; i &lt; arr.length; i++) &#123; binarySortTree.add(new BinarySortNode(arr[i])); &#125; // 中序遍历二叉排序树 System.out.println("中序遍历二叉排序树~"); // 1, 3, 5, 7, 9, 10, 12 binarySortTree.infixOrder();// System.out.println("删除叶子节点");// binarySortTree.delNode(9);// binarySortTree.infixOrder();// System.out.println("删除只有一颗子树的节点");// binarySortTree.delNode(1);// binarySortTree.infixOrder();// System.out.println("删除只有两颗子树的节点");// binarySortTree.delNode(7);// binarySortTree.infixOrder(); binarySortTree.delNode(2); binarySortTree.delNode(5); binarySortTree.delNode(9); binarySortTree.delNode(12); binarySortTree.delNode(7); binarySortTree.delNode(3); binarySortTree.delNode(10); binarySortTree.infixOrder(); &#125;&#125;/** * 创建二叉排序树 */class BinarySortTree &#123; private BinarySortNode root; public BinarySortNode getRoot() &#123; return root; &#125; /** * 添加节点的方法 * * @param node node */ public void add(BinarySortNode node) &#123; // 如果root为空则直接让root指向node if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("二叉排序树为空，不能遍历"); &#125; &#125; /** * 查找要删除的节点 */ public BinarySortNode search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; /** * 查找父节点 */ public BinarySortNode searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; /** * 1. 返回的 以node 为根节点的二叉排序树的最小节点的值 * 2. 删除node 为根节点的二叉排序树的最小节点 * * @param node 传入的节点(当做二叉排序树的根节点) * @return 返回的 以node 为根节点的二叉排序树的最小节点的值 */ public int delRightTreeMin(BinarySortNode node) &#123; BinarySortNode target = node; // 循环的查找左子节点，就会找到最小值 while (target.left != null) &#123; target = target.left; &#125; // 这时 target就指向了最小节点 // 删除最小节点 delNode(target.value); return target.value; &#125; /** * 删除节点 */ public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; // 先去找到要删除的节点 targetNode BinarySortNode targetNode = search(value); if (targetNode == null) &#123; return; &#125; // 如果我们发现当前这棵二叉排序树只有一个节点 if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; // 去找到targetNode的父节点 BinarySortNode parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; //判断targetNode 是父节点的左子节点，还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; // 是左子节点 parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; // 是右子节点 parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123; // 删除有两颗子树的节点 targetNode.value = delRightTreeMin(targetNode.right); &#125; else &#123; // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) &#123; if (parent != null) &#123; // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == targetNode.value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是 parent 的右子节点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; // 如果要删除的节点有右子节点 if (parent != null) &#123; // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == targetNode.value) &#123; parent.left = targetNode.right; &#125; else &#123; // targetNode 是 parent 的右子节点 parent.right = targetNode.right; &#125; &#125;else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125;&#125;/** * 创建Node节点 */class BinarySortNode &#123; int value; BinarySortNode left; BinarySortNode right; public BinarySortNode(int value) &#123; this.value = value; &#125; /** * 查找要删除的节点 * * @param value 希望删除的节点的值 * @return 如果找到返回该节点，否则返回null */ public BinarySortNode search(int value) &#123; if (value == this.value) &#123; return this; &#125; else if (value &lt; this.value) &#123; // 如果查找的值小于当前节点，向左子树递归查找 // 如果左子节点为空 if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; // 如果查找的值不小于当前节点，向右子树递归查找 if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; /** * 查找要删除节点的父节点 * * @param value 要找到的节点的值 * @return 返回的是要删除的节点的父节点，如果没有就返回null */ public BinarySortNode searchParent(int value) &#123; if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; // 如果查找的值小于当前节点的值, 并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) &#123; // 向左子树递归查找 return this.left.searchParent(value); &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; // 向右子树递归查找 return this.right.searchParent(value); &#125; else &#123; // 没有找到父节点 return null; &#125; &#125; &#125; /** * 添加节点的方法 * 递归的形式添加节点，注意需要满足二叉排序树的要求 */ public void add(BinarySortNode node) &#123; if (node == null) &#123; return; &#125; // 判断传入的节点的值，和当前子树的根节点的值关系 if (node.value &lt; this.value) &#123; // 如果当前节点左子节点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的节点的值大于当前节点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; @Override public String toString() &#123; return "BinarySortNode&#123;" + "value=" + value + '&#125;'; &#125;&#125; 平衡二叉树问题引入给定一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在。 BST 存在的问题分析: 左子树全部为空，从形式上看，更像一个单链表。 插入速度没有影响。 查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢。 解决方案-平衡二叉树(AVL)。 基本介绍 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL 树， 可以保证查询效率较高。 具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 举例说明, 看看下面哪些AVL 树, 为什么? 左旋转 要求：给定一个数列 {4,3,6,5,7,8} ，创建出对应的平衡二叉树。 思路分析 代码实现123456789101112131415161718//核心方法，全部代码放在后面/** * 左旋转方法 */private void leftRotate() &#123; // 创建新的节点，以当前根节点的值 AVLNode newNode = new AVLNode(this.value); // 把新的节点的左子树设置成当前节点的左子树 newNode.left = left; // 把新的节点的右子树设置成带你过去节点的右子树的左子树 newNode.right = right.left; // 把当前节点的值替换成右子节点的值 value = right.value; // 把当前节点的右子树设置成当前节点右子树的右子树 right = right.right; // 把当前节点的左子树(左子节点)设置成新的节点 left = newNode;&#125; 右旋转要求：给定一个数列 {10,12, 8, 9, 7, 6}，创建出对应的平衡二叉树。 思路分析 代码实现123456789101112131415161718//核心方法，全部代码放在后面/** * 右旋转方法 */private void rightRotate() &#123; // 创建新的节点，以当前根节点的值 AVLNode newNode = new AVLNode(this.value); // 把新的节点的右子树设置成当前节点的右子树 newNode.right = right; // 把新的节点的左子树设置成带你过去节点的左子树的右子树 newNode.left = left.right; // 把当前节点的值替换成左子节点的值 value = left.value; // 把当前节点的左子树设置成当前节点左子树的左子树 left = left.left; // 把当前节点的右子树(右子节点)设置成新的节点 right = newNode;&#125; 双旋转问题分析前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列 int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成AVL 树。int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成AVL 树。 解决思路 当符号右旋转的条件时。 如果它的左子树的右子树高度大于它的左子树的高度。 先对当前这个结点的左节点进行左旋转。 在对当前结点进行右旋转的操作即可。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367//AVL 树的汇总代码(完整代码)public class AVLTreeDemo &#123; public static void main(String[] args) &#123;// int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;// int[] arr = &#123;10, 12, 8, 9, 7, 6&#125;; int[] arr = &#123;10, 11, 7, 6, 8, 9&#125;; // 创建一个 AVLTree对象 AVLTree avlTree = new AVLTree(); // 添加节点 for (int i = 0; i &lt; arr.length; i++) &#123; avlTree.add(new AVLNode(arr[i])); &#125; // 遍历 System.out.println("中序遍历"); avlTree.infixOrder(); System.out.println("树的高度=" + avlTree.getRoot().height()); System.out.println("树的左子树高度=" + avlTree.getRoot().leftHeight()); System.out.println("树的右子树高度=" + avlTree.getRoot().rightHeight()); System.out.println("当前的根节点=" + avlTree.getRoot()); &#125;&#125;/** * 创建平衡二叉树 */class AVLTree &#123; private AVLNode root; public AVLNode getRoot() &#123; return root; &#125; /** * 添加节点的方法 * * @param node node */ public void add(AVLNode node) &#123; // 如果root为空则直接让root指向node if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("二叉排序树为空，不能遍历"); &#125; &#125; /** * 查找要删除的节点 */ public AVLNode search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; /** * 查找父节点 */ public AVLNode searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; /** * 1. 返回的 以node 为根节点的二叉排序树的最小节点的值 * 2. 删除node 为根节点的二叉排序树的最小节点 * * @param node 传入的节点(当做二叉排序树的根节点) * @return 返回的 以node 为根节点的二叉排序树的最小节点的值 */ public int delRightTreeMin(AVLNode node) &#123; AVLNode target = node; // 循环的查找左子节点，就会找到最小值 while (target.left != null) &#123; target = target.left; &#125; // 这时 target就指向了最小节点 // 删除最小节点 delNode(target.value); return target.value; &#125; /** * 删除节点 */ public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; // 先去找到要删除的节点 targetNode AVLNode targetNode = search(value); if (targetNode == null) &#123; return; &#125; // 如果我们发现当前这棵二叉排序树只有一个节点 if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; // 去找到targetNode的父节点 AVLNode parent = searchParent(value); // 如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; //判断targetNode 是父节点的左子节点，还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; // 是左子节点 parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; // 是右子节点 parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123; // 删除有两颗子树的节点 targetNode.value = delRightTreeMin(targetNode.right); &#125; else &#123; // 删除只有一颗子树的节点 // 如果要删除的节点有左子节点 if (targetNode.left != null) &#123; if (parent != null) &#123; // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == targetNode.value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是 parent 的右子节点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; // 如果要删除的节点有右子节点 if (parent != null) &#123; // 如果 targetNode 是 parent 的左子节点 if (parent.left.value == targetNode.value) &#123; parent.left = targetNode.right; &#125; else &#123; // targetNode 是 parent 的右子节点 parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125;&#125;/** * 创建Node节点 */class AVLNode &#123; int value; AVLNode left; AVLNode right; public AVLNode(int value) &#123; this.value = value; &#125; /** * 返回左子树的高度 */ public int leftHeight() &#123; if (left == null) &#123; return 0; &#125; return left.height(); &#125; /** * 返回右子树的高度 */ public int rightHeight() &#123; if (right == null) &#123; return 0; &#125; return right.height(); &#125; /** * 返回以该节点为根节点的树的高度 */ public int height() &#123; return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; &#125; /** * 左旋转方法 */ private void leftRotate() &#123; // 创建新的节点，以当前根节点的值 AVLNode newNode = new AVLNode(this.value); // 把新的节点的左子树设置成当前节点的左子树 newNode.left = left; // 把新的节点的右子树设置成带你过去节点的右子树的左子树 newNode.right = right.left; // 把当前节点的值替换成右子节点的值 value = right.value; // 把当前节点的右子树设置成当前节点右子树的右子树 right = right.right; // 把当前节点的左子树(左子节点)设置成新的节点 left = newNode; &#125; /** * 右旋转方法 */ private void rightRotate() &#123; // 创建新的节点，以当前根节点的值 AVLNode newNode = new AVLNode(this.value); // 把新的节点的右子树设置成当前节点的右子树 newNode.right = right; // 把新的节点的左子树设置成带你过去节点的左子树的右子树 newNode.left = left.right; // 把当前节点的值替换成左子节点的值 value = left.value; // 把当前节点的左子树设置成当前节点左子树的左子树 left = left.left; // 把当前节点的右子树(右子节点)设置成新的节点 right = newNode; &#125; /** * 查找要删除的节点 * * @param value 希望删除的节点的值 * @return 如果找到返回该节点，否则返回null */ public AVLNode search(int value) &#123; if (value == this.value) &#123; return this; &#125; else if (value &lt; this.value) &#123; // 如果查找的值小于当前节点，向左子树递归查找 // 如果左子节点为空 if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; // 如果查找的值不小于当前节点，向右子树递归查找 if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; /** * 查找要删除节点的父节点 * * @param value 要找到的节点的值 * @return 返回的是要删除的节点的父节点，如果没有就返回null */ public AVLNode searchParent(int value) &#123; if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; // 如果查找的值小于当前节点的值, 并且当前节点的左子节点不为空 if (value &lt; this.value &amp;&amp; this.left != null) &#123; // 向左子树递归查找 return this.left.searchParent(value); &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; // 向右子树递归查找 return this.right.searchParent(value); &#125; else &#123; // 没有找到父节点 return null; &#125; &#125; &#125; /** * 添加节点的方法 * 递归的形式添加节点，注意需要满足二叉排序树的要求 */ public void add(AVLNode node) &#123; if (node == null) &#123; return; &#125; // 判断传入的节点的值，和当前子树的根节点的值关系 if (node.value &lt; this.value) &#123; // 如果当前节点左子节点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的节点的值大于当前节点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; // 当添加完一个节点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转 if (rightHeight() - leftHeight() &gt; 1) &#123; // 如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123; // 先对当前节点的右节点(右子树)-&gt;右旋转 right.rightRotate(); &#125; leftRotate(); // 必须要!!! return; &#125; // 当添加完一个节点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转 if (leftHeight() - rightHeight() &gt; 1) &#123; // 如果它的左子树的右子树高度大于它的左子树的左子树的高度 if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123; // 先对当前节点的左节点(左子树)-&gt;左旋转 left.leftRotate(); &#125; rightRotate(); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; @Override public String toString() &#123; return "AVLNode&#123;" + "value=" + value + '&#125;'; &#125;&#125; 多路查找树二叉树与B 树二叉树的问题分析二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树。 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题: 在构建二叉树时，需要多次进行i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响。 节点海量，也会造成二叉树的高度很大，会降低操作速度。 多叉树 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）。 后面的2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。 举例说明(下面2-3 树就是一颗多叉树)。 B树的基本介绍B树通过重新组织节点，降低树的高度，并且减少i/o 读写次数来提升效率。 如图B树通过重新组织节点， 降低了树的高度。 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O 就可以完全载入。 将树的度M 设置为1024，在600 亿个元素中最多只需要4 次I/O 操作就可以读取到想要的元素, B 树(B+)广泛应用于文件存储系统以及数据库系统中。 2-3树2-3 树是最简单的B 树结构, 具有如下特点： 2-3 树的所有叶子节点都在同一层。(只要是B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。 2-3 树是由二节点和三节点构成的树。 应用案例将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成2-3 树，并保证数据插入的大小顺序。(演示一下构建2-3树的过程) 插入规则： 2-3 树的所有叶子节点都在同一层。(只要是B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3 个条件。 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则。 其它说明除了23 树，还有234 树等，概念和23 树类似，也是一种B 树。如图： B树、B+树和B*树B 树介绍B-tree 树即B 树，B 即Balanced，平衡的意思。有人把B-tree 翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B 树又是另一种树。实际上，B-tree 就是指的B 树。前面已经介绍了2-3 树和2-3-4 树，他们就是B 树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql 时，经常听到说某种类型的索引是基于B 树或者B+树的，如图： B树的说明: B 树的阶：节点的最多子节点个数。比如2-3 树的阶是3，2-3-4 树的阶是4。 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据。 搜索有可能在非叶子结点结束。 其搜索性能等价于在关键字全集内做一次二分查找。 B+树介绍B+树是B 树的变体，也是一种多路搜索树。 B+树的说明: B+树的搜索与B 树也基本相同，区别是B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中。 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。 更适合文件索引系统。 B 树和B+树各有自己的应用场景，不能说B+树完全比B 树好，反之亦然。 B*树介绍B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。 B*树的说明: B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为的1/2。 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>赫夫曼树</tag>
        <tag>赫夫曼编码</tag>
        <tag>二叉排序树</tag>
        <tag>平衡二叉树</tag>
        <tag>AVL树</tag>
        <tag>多路查找树</tag>
        <tag>B树</tag>
        <tag>B+树</tag>
        <tag>B*树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（树结构基础）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%91%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[二叉树为什么需要树这种数据结构数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低。 操作示意图： 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 。 操作示意图： 树存储方式的分析能提高数据存储，读取的效率, 比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。 案例: [7, 3, 10, 1, 5, 9, 12] 树示意图 树的常用术语(结合示意图理解): 节点 根节点 父节点 子节点 叶子节点(没有子节点的节点) 节点的权(节点值) 路径(从root 节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林:多颗子树构成森林 二叉树的概念 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 二叉树的子节点分为左节点和右节点。 示意图： 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。 遍历节点可使用前序，中序和后序对下面的二叉树进行遍历。 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 小结: 看输出父节点的顺序，就确定是前序，中序还是后序 遍历节点应用实例(前序,中序,后序)应用实例的说明和思路 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, "宋江"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 System.out.println("前序遍历"); // 1,2,3,5,4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2,1,5,3,4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2,5,4,3,1 binaryTree.postOrder(); &#125;&#125;/** * 二叉树 */class BinaryTree &#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; /** * 前序遍历 */ public void preOrder() &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; if (root != null) &#123; root.postOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125;&#125;class HeroNode &#123; private int no; private String name; /** * 默认null */ private HeroNode left; /** * 默认null */ private HeroNode right; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return "HeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125; /** * 前序遍历 */ public void preOrder() &#123; // 输出父结点 System.out.println(this); // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; // 输出父结点 System.out.println(this); // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.postOrder(); &#125; // 输出父结点 System.out.println(this); &#125;&#125; 查找指定节点要求： 请编写前序查找，中序查找和后序查找的方法。 并分别使用三种查找方式，查找heroNo = 5 的节点 并分析各种查找方式，分别比较了多少次 思路分析图解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, "宋江"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 System.out.println("前序遍历"); // 1,2,3,5,4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2,1,5,3,4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2,5,4,3,1 binaryTree.postOrder(); System.out.println(); System.out.println("--------------------------"); int no = 5; // 前序遍历 // 前序遍历的次数：4 System.out.println("前序遍历方式~~~"); HeroNode resNode = binaryTree.preOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); // 中序遍历查找 // 中序遍历3 次 System.out.println("中序遍历方式~~~"); resNode = binaryTree.infixOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); //后序遍历查找 //后序遍历查找的次数2 次 System.out.println("后序遍历方式~~~"); resNode = binaryTree.postOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; &#125;&#125;/** * 二叉树增加方法，其他代码同上，省略 */class BinaryTree &#123; /** * 前序查找 */ public HeroNode preOrderSearch(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; /** * 中序查找 */ public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; /** * 后序查找 */ public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;/** * HeroNode增加方法，其他代码同上，省略 */class HeroNode &#123; /** * 前序遍历查找 * * @param no no */ public HeroNode preOrderSearch(int no) &#123; System.out.println("进入前序遍历"); // 比较当前结点是不是 if (this.no == no) &#123; return this; &#125; // 1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找 // 2.如果左递归前序查找，找到结点，则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; // 说明我们左子树找到 if (resNode != null) &#123; return resNode; &#125; // 1.左递归前序查找，找到结点，则返回，否继续判断 // 2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; /** * 中序遍历查找 * * @param no no */ public HeroNode infixOrderSearch(int no) &#123; // 判断当前结点的左子节点是否为空，如果不为空，则递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println("进入中序遍历"); // 如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点 if (this.no == no) &#123; return this; &#125; // 否则继续进行右递归的中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; /** * 后序遍历查找 * * @param no no */ public HeroNode postOrderSearch(int no) &#123; // 判断当前结点的左子节点是否为空，如果不为空，则递归后序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; // 说明在左子树找到 return resNode; &#125; // 如果左子树没有找到，则向右子树递归进行后序遍历查找 if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println("进入后序查找"); // 如果左右子树都没有找到，就比较当前结点是不是 if (this.no == no) &#123; return this; &#125; return null; &#125;&#125; 删除节点要求： 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树 测试，删除掉5 号叶子节点和3 号子树 思路分析图解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, "宋江"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 System.out.println("前序遍历"); // 1,2,3,5,4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2,1,5,3,4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2,5,4,3,1 binaryTree.postOrder(); System.out.println(); System.out.println("--------------------------"); int no = 5; // 前序遍历 // 前序遍历的次数：4 System.out.println("前序遍历方式~~~"); HeroNode resNode = binaryTree.preOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); // 中序遍历查找 // 中序遍历3 次 System.out.println("中序遍历方式~~~"); resNode = binaryTree.infixOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); //后序遍历查找 //后序遍历查找的次数2 次 System.out.println("后序遍历方式~~~"); resNode = binaryTree.postOrderSearch(no); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no = %d 的英雄", no); &#125; System.out.println(); System.out.println("--------------------------"); //测试一把删除结点 System.out.println("删除前,前序遍历"); binaryTree.preOrder(); // 1,2,3,5,4 binaryTree.delNode(5); binaryTree.delNode(3); System.out.println("删除后，前序遍历"); binaryTree.preOrder(); // 1,2,3,4 &#125;&#125;/** * 二叉树增加方法，其他代码同上，省略 */class BinaryTree &#123; /** * 删除节点 * * @param no no */ public void delNode(int no) &#123; if (root != null) &#123; // 如果只有一个root 结点, 这里立即判断root 是不是就是要删除结点 if (root.getNo() == no) &#123; root = null; &#125; else &#123; // 递归删除 root.delNode(no); &#125; &#125; else &#123; System.out.println("空树，不能删除~"); &#125; &#125;&#125;/** * HeroNode增加方法，其他代码同上，省略 */class HeroNode &#123; /** * 递归删除结点 * 1.如果删除的节点是叶子节点，则删除该节点 * 2.如果删除的节点是非叶子节点，则删除该子树 * * @param no no */ public void delNode(int no) &#123; /* * 思路 * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. * 2. 如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) * 3. 如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this.right= null; 并且就返回(结束递归删除) * 4. 如果第2步和第3步没有删除结点，那么我们就需要向左子树进行递归删除 * 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. */ // 2.如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; // 3. 如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this.right= null; 并且就返回(结束递归删除) if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; // 4.我们就需要向左子树进行递归删除 if (this.left != null) &#123; this.left.delNode(no); &#125; // 5.则应当向右子树进行递归删除 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125;&#125; 顺序存储二叉树顺序存储二叉树的概念基本说明从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看右面的示意图。 顺序存储二叉树的特点 顺序二叉树通常只考虑完全二叉树 第 n 个元素的左子节点为2 * n + 1 第 n 个元素的右子节点为2 * n + 2 第 n 个元素的父节点为(n-1) / 2 n : 表示二叉树中的第几个元素(按0 开始编号如图所示) 顺序存储二叉树遍历需求: 给定一个数组{1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。前序遍历的结果应当为1,2,4,5,3,6,7。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ArrBinaryTreeDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;; // 创建一个ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); // 1,2,4,5,3,6,7 arrBinaryTree.preOrder(); &#125;&#125;/** * 编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历 */class ArrBinaryTree &#123; /** * 存储数据结点的数组 */ private int[] arr; public ArrBinaryTree(int[] arr) &#123; this.arr = arr; &#125; /** * 重载preOrder */ public void preOrder() &#123; this.preOrder(0); &#125; /** * 编写一个方法，完成顺序存储二叉树的前序遍历 * * @param index 数组的下标 */ public void preOrder(int index) &#123; // 如果数组为空，或者arr.length = 0 if (arr == null || arr.length == 0) &#123; System.out.println("数组为空，不能按照二叉树的前序遍历"); &#125; // 输出当前这个元素 System.out.println(arr[index]); // 向左递归遍历 int leftIndex = index * 2 + 1; if (leftIndex &lt; arr.length) &#123; preOrder(leftIndex); &#125; // 向右递归遍历 int rightIndex = index * 2 + 2; if (rightIndex &lt; arr.length) &#123; preOrder(rightIndex); &#125; &#125;&#125; 线索化二叉树问题分析将数列{1, 3, 6, 8, 10, 14 } 构建成一颗二叉树。n+1=7 当我们对上面的二叉树进行中序遍历时，数列为{8, 3, 10, 1, 6, 14 } 但是6, 8, 10, 14 这几个节点的左右指针，并没有完全的利用上 如果我们希望充分的利用各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 解决方案-线索二叉树 基本介绍 n 个结点的二叉链表中含有n+1 【公式2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(ThreadedBinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 线索化二叉树要求：将下面的二叉树，线索化为中序线索二叉树。中序遍历的数列为{8, 3, 10, 1, 14, 6}。思路：中序遍历的结果：{8, 3, 10, 1, 14, 6}。 说明：当线索化二叉树后，Node 节点的属性left 和right ，有如下情况： left 指向的是左子树，也可能是指向的前驱节点。 比如① 节点left 指向的左子树, 而⑩ 节点的left 指向的就是前驱节点。 right 指向的是右子树，也可能是指向后继节点。比如① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点。 代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183public class ThreadedBinaryTreeDemo &#123; public static void main(String[] args) &#123; // 测试一把中序线索二叉树的功能 ThreadedHeroNode root = new ThreadedHeroNode(1, "tom"); ThreadedHeroNode node2 = new ThreadedHeroNode(3, "jack"); ThreadedHeroNode node3 = new ThreadedHeroNode(6, "smith"); ThreadedHeroNode node4 = new ThreadedHeroNode(8, "mary"); ThreadedHeroNode node5 = new ThreadedHeroNode(10, "king"); ThreadedHeroNode node6 = new ThreadedHeroNode(14, "dim"); // 二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); // 测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); // 测试: 以10 号节点测试 ThreadedHeroNode leftNode = node5.getLeft(); ThreadedHeroNode rightNode = node5.getRight(); // 3 System.out.println("10 号结点的前驱结点是=" + leftNode); // 1 System.out.println("10 号结点的后继结点是=" + rightNode); &#125;&#125;/** * 线索化二叉树, 实现了线索化功能的二叉树 */class ThreadedBinaryTree &#123; private ThreadedHeroNode root; /** * 当前线索化二叉树线索化过的最后一个节点 * &lt;/p&gt; * 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 * 在递归进行线索化时，pre 总是保留前一个结点 */ private ThreadedHeroNode pre = null; public void setRoot(ThreadedHeroNode root) &#123; this.root = root; &#125; public void threadedNodes() &#123; this.threadedNodes(root); &#125; /** * 二叉树进行中序线索化的方法 * * @param node 当前需要线索化的结点 */ public void threadedNodes(ThreadedHeroNode node) &#123; // 如果node==null, 不能线索化 if (node == null) &#123; return; &#125; // (一)先线索化左子树 threadedNodes(node.getLeft()); // (二)线索化当前结点 // 处理当前结点的前驱结点 // 以 8 结点来理解 // 8 结点的.left = null , 8 结点的.leftType = 1 if (node.getLeft() == null) &#123; // 让当前结点的左指针指向前驱结点 node.setLeft(pre); node.setLeftType(1); &#125; // 处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让树的前驱结点的右指针指向当前结点 pre.setRight(node); // 修改树的前驱结点的右指针类型 pre.setRightType(1); &#125; // !!! 每处理一个结点后，将当前结点设置为这棵树的前驱结点 pre = node; // (三)再线索化右子树 threadedNodes(node.getRight()); &#125;&#125;class ThreadedHeroNode &#123; private int no; private String name; /** * 默认null */ private ThreadedHeroNode left; /** * 默认null */ private ThreadedHeroNode right; /** * 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 */ private int leftType; /** * 如果rightType == 0 表示指向是右子树, 如果 1 则表示指向后继结点 */ private int rightType; public ThreadedHeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ThreadedHeroNode getLeft() &#123; return left; &#125; public void setLeft(ThreadedHeroNode left) &#123; this.left = left; &#125; public ThreadedHeroNode getRight() &#123; return right; &#125; public void setRight(ThreadedHeroNode right) &#123; this.right = right; &#125; public int getLeftType() &#123; return leftType; &#125; public void setLeftType(int leftType) &#123; this.leftType = leftType; &#125; public int getRightType() &#123; return rightType; &#125; public void setRightType(int rightType) &#123; this.rightType = rightType; &#125; @Override public String toString() &#123; return "ThreadedHeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125;&#125; 遍历线索化二叉树要求：对前面的中序线索化的二叉树， 进行遍历。 思路：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213public class ThreadedBinaryTreeDemo &#123; public static void main(String[] args) &#123; // 测试一把中序线索二叉树的功能 ThreadedHeroNode root = new ThreadedHeroNode(1, "tom"); ThreadedHeroNode node2 = new ThreadedHeroNode(3, "jack"); ThreadedHeroNode node3 = new ThreadedHeroNode(6, "smith"); ThreadedHeroNode node4 = new ThreadedHeroNode(8, "mary"); ThreadedHeroNode node5 = new ThreadedHeroNode(10, "king"); ThreadedHeroNode node6 = new ThreadedHeroNode(14, "dim"); // 二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); // 测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); // 测试: 以10 号节点测试 ThreadedHeroNode leftNode = node5.getLeft(); ThreadedHeroNode rightNode = node5.getRight(); // 3 System.out.println("10 号结点的前驱结点是=" + leftNode); // 1 System.out.println("10 号结点的后继结点是=" + rightNode); System.out.println("使用线索化的方式遍历线索化二叉树"); // 8, 3, 10, 1, 14, 6 threadedBinaryTree.threadedList(); &#125;&#125;/** * 线索化二叉树, 实现了线索化功能的二叉树 */class ThreadedBinaryTree &#123; private ThreadedHeroNode root; /** * 当前线索化二叉树线索化过的最后一个节点 * &lt;/p&gt; * 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 * 在递归进行线索化时，pre 总是保留前一个结点 */ private ThreadedHeroNode pre = null; public void setRoot(ThreadedHeroNode root) &#123; this.root = root; &#125; public void threadedNodes() &#123; this.threadedNodes(root); &#125; /** * 二叉树进行中序线索化的方法 * * @param node 当前需要线索化的结点 */ public void threadedNodes(ThreadedHeroNode node) &#123; // 如果node==null, 不能线索化 if (node == null) &#123; return; &#125; // (一)先线索化左子树 threadedNodes(node.getLeft()); // (二)线索化当前结点 // 处理当前结点的前驱结点 // 以 8 结点来理解 // 8 结点的.left = null , 8 结点的.leftType = 1 if (node.getLeft() == null) &#123; // 让当前结点的左指针指向前驱结点 node.setLeft(pre); node.setLeftType(1); &#125; // 处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让树的前驱结点的右指针指向当前结点 pre.setRight(node); // 修改树的前驱结点的右指针类型 pre.setRightType(1); &#125; // !!! 每处理一个结点后，将当前结点设置为这棵树的前驱结点 pre = node; // (三)再线索化右子树 threadedNodes(node.getRight()); &#125; /** * 遍历线索化二叉树的方法 */ public void threadedList() &#123; // 定义一个变量，存储当前遍历的结点，从 root 开始 ThreadedHeroNode node = root; while(node != null)&#123; // 循环的找到 leftType == 1 的结点，第一个找到就是 8 结点 // 后面随着遍历而变化,因为当 leftType==1 时，说明该结点是按照线索化处理后的有效结点 while(node.getLeftType() == 0)&#123; node = node.getLeft(); &#125; // 打印当前这个结点 System.out.println(node); // 如果当前结点的右指针指向的是后继结点,就一直输出 while(node.getRightType() == 1) &#123; // 获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); &#125; // 替换这个遍历的结点 node = node.getRight(); &#125; &#125;&#125;class ThreadedHeroNode &#123; private int no; private String name; /** * 默认null */ private ThreadedHeroNode left; /** * 默认null */ private ThreadedHeroNode right; /** * 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 */ private int leftType; /** * 如果rightType == 0 表示指向是右子树, 如果 1 则表示指向后继结点 */ private int rightType; public ThreadedHeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ThreadedHeroNode getLeft() &#123; return left; &#125; public void setLeft(ThreadedHeroNode left) &#123; this.left = left; &#125; public ThreadedHeroNode getRight() &#123; return right; &#125; public void setRight(ThreadedHeroNode right) &#123; this.right = right; &#125; public int getLeftType() &#123; return leftType; &#125; public void setLeftType(int leftType) &#123; this.leftType = leftType; &#125; public int getRightType() &#123; return rightType; &#125; public void setRightType(int rightType) &#123; this.rightType = rightType; &#125; @Override public String toString() &#123; return "ThreadedHeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>顺序二叉树</tag>
        <tag>线索化二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（查找算法）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%89.html</url>
    <content type="text"><![CDATA[查找算法介绍在java 中，我们常用的查找有四种: 顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找 线性查找算法有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】要求: 如果找到了，就提示找到，并给出下标值。 代码实现123456789101112131415161718192021222324252627public class SeqSearch &#123; public static void main(String[] args) &#123; // 没有顺序的数组 int arr[] = &#123;1, 9, 11, -1, 34, 89&#125;; int index = seqSearch(arr, 89); if (index == -1) &#123; System.out.println("没有找到"); &#125; else &#123; System.out.println("找到，下标为=" + index); &#125; &#125; /** * 这里我们实现的线性查找是找到一个满足条件的值，就返回 */ public static int seqSearch(int[] arr, int value) &#123; // 线性查找是逐一比对，发现有相同值，就返回下标 for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == value) &#123; return i; &#125; &#125; return -1; &#125;&#125; 二分查找算法请对一个有序数组进行二分查找{1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 思路分析 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BinarySearch &#123; // 注意：使用二分查找的前提是该数组是有序的。 public static void main(String[] args) &#123; int arr[] = &#123;1, 8, 10, 89, 1000, 1000, 1234&#125;; int resIndex = binarySearch(arr, 0, arr.length - 1, 1234); System.out.println("resIndex=" + resIndex); List&lt;Integer&gt; list = binarySearch2(arr, 0, arr.length - 1, 1000); System.out.println("resIndex=" + list); &#125; /** * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回-1 */ public static int binarySearch(int[] arr, int left, int right, int findVal) &#123; // 当left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向右递归 return binarySearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125; /** * 思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000 * &lt;p&gt; * 思路分析 * 1. 在找到mid 索引值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList * 4. 将Arraylist 返回 */ public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123; // 当left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return new ArrayList&lt;&gt;(); &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向右递归 return binarySearch2(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch2(arr, left, mid - 1, findVal); &#125; else &#123; List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;(); // 向mid 索引值的左边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList int temp = mid - 1; while (true) &#123; // 退出 if (temp &lt; 0 || arr[temp] != findVal) &#123; break; &#125; // 否则，就temp 放入到resIndexlist resIndexlist.add(temp); // temp 左移 temp--; &#125; resIndexlist.add(mid); // 向mid 索引值的右边扫描，将所有满足1000， 的元素的下标，加入到集合ArrayList temp = mid + 1; while (true) &#123; // 退出 if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123; break; &#125; // 否则，就temp 放入到resIndexlist resIndexlist.add(temp); // temp 右移 temp++; &#125; return resIndexlist; &#125; &#125;&#125; 插值查找算法基本介绍插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid 处开始查找。 基本原理 将折半查找中的求mid 索引的公式, low 表示左边索引left, high 表示右边索引right。 key 就是前面我们讲的findVal int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ; //插值索引 对应前面的代码公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 思路分析 代码实现请对一个有序数组进行插值查找{1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 123456789101112131415161718192021222324252627282930313233343536public class InsertValueSearch &#123; public static void main(String[] args) &#123; int arr[] = &#123;1, 8, 10, 89, 1000, 1000, 1234&#125;; int index = insertValueSearch(arr, 0, arr.length - 1, 89); System.out.println("index = " + index); &#125; /** * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回-1 */ public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; // 注意：findVal &lt; arr[0] 和findVal &gt; arr[arr.length - 1] 必须需要 // 否则我们得到的mid 可能越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123; return -1; &#125; // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; // 说明应该向右边递归 if (findVal &gt; midVal) &#123; return insertValueSearch(arr, mid + 1, right, findVal); // 说明向左递归查找 &#125; else if (findVal &lt; midVal) &#123; return insertValueSearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125;&#125; 注意事项 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。 关键字分布不均匀的情况下，该方法不一定比折半查找要好。 斐波那契(黄金分割法)查找算法基本介绍 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意想不到的效果。 斐波那契数列{1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618。 基本原理斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示 对F(k-1)-1 的理解： 由斐波那契数列F[k]=F[k-1]+F[k-2] 的性质，可以得到（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1 和F[k-2]-1 的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1。 类似的，每一子段也可以用相同的方式分割。 但顺序表长度n 不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n 增加至F[k]-1。这里的k 值只要能使得F[k]-1 恰好大于或等于n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1 到F[k]-1 位置），都赋为n 位置的值即可。 123while(n &gt; fib(k)-1)&#123; k++; &#125; 代码实现请对一个有序数组进行斐波那契查找{1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class FibonacciSearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 8, 10, 89, 1000, 1234&#125;; System.out.println("index=" + fibSearch(arr, 89)); &#125; public static int maxSize = 20; /** * 因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 * 非递归方法得到一个斐波那契数列 */ public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; /** * @param a 数组 * @param key 我们需要查找的关键码(值) * @return 返回对应的下标，如果没有-1 */ public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; //表示斐波那契分割数值的下标 int k = 0; // 存放mid 值 int mid = 0; // 获取到斐波那契数列 int[] f = fib(); // 获取到斐波那契分割数值的下标 while (high &gt; f[k] - 1) &#123; k++; &#125; //因为f[k] 值可能大于a 的长度，因此我们需要使用Arrays 类，构造一个新的数组，并指向temp[] //不足的部分会使用0 填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a 数组最后的数填充temp //举例: //temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125; for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; // 使用while 来循环处理，找到我们的数key // 只要这个条件满足，就可以找 while (low &lt;= high) &#123; mid = low + f[k - 1] - 1; // 我们应该继续向数组的前面查找(左边) if (key &lt; temp[mid]) &#123; high = mid - 1; // 为什么是k-- // 说明 // 1. 全部元素= 前面的元素+ 后边元素 // 2. f[k] = f[k-1] + f[k-2] // 因为前面有f[k-1]个元素,所以可以继续拆分f[k-1] = f[k-2] + f[k-3] // 即在f[k-1] 的前面继续查找k-- // 即下次循环mid = f[k-1-1]-1 k--; &#125; else if (key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边) low = mid + 1; // 为什么是k -=2 // 说明 // 1. 全部元素= 前面的元素+ 后边元素 // 2. f[k] = f[k-1] + f[k-2] // 3. 因为后面我们有f[k-2] 所以可以继续拆分f[k-2] = f[k-3] + f[k-4] // 4. 即在f[k-2] 的前面进行查找k -=2 // 5. 即下次循环mid = f[k - 1 - 2] - 1 k -= 2; &#125; else &#123; //找到 // 需要确定，返回的是哪个下标 if (mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二分查找算法</tag>
        <tag>查找算法</tag>
        <tag>插值查找算法</tag>
        <tag>斐波那契查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（哈希表）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89.html</url>
    <content type="text"><![CDATA[基本介绍散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 google上机题目有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id 时,要求查找到该员工的所有信息.要求: 不使用数据库,,速度越快越好=&gt;哈希表(散列) 添加时，保证按照id 从低到高插入[课后思考：如果id 不是从低到高插入，但要求各条链表仍是从低到高，怎么解决? 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] 思路分析并画出示意图 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public class HashTabDemo &#123; public static void main(String[] args) &#123; //创建哈希表 HashTab hashTab = new HashTab(7); //写一个简单的菜单 String key = ""; Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.println("add: 添加雇员"); System.out.println("list: 显示雇员"); System.out.println("find: 查找雇员"); System.out.println("exit: 退出系统"); key = scanner.next(); switch (key) &#123; case "add": System.out.println("输入id"); int id = scanner.nextInt(); System.out.println("输入名字"); String name = scanner.next(); //创建雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case "list": hashTab.list(); break; case "find": System.out.println("请输入要查找的id"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case "exit": scanner.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;/** * 创建HashTab 管理多条链表 */class HashTab &#123; private EmpLinkedList[] empLinkedListArray; private int size; /** * 构造器 * * @param size size */ public HashTab(int size) &#123; this.size = size; // 初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; /** * 添加雇员 * * @param emp emp */ public void add(Emp emp) &#123; //根据员工的id ,得到该员工应当添加到哪条链表 int empLinkedListNo = hashFun(emp.id); //将emp 添加到对应的链表中 empLinkedListArray[empLinkedListNo].add(emp); &#125; /** * 遍历所有的链表,遍历hashtab */ public void list() &#123; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i].list(i); &#125; &#125; /** * 根据输入的id,查找雇员 * * @param id id */ public void findEmpById(int id) &#123; // 使用散列函数确定到哪条链表查找 int empLinkedListNo = hashFun(id); Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id); if (emp != null) &#123; // 找到 System.out.printf("在第%d条链表中找到雇员id = %d\n", (empLinkedListNo + 1), id); &#125; else &#123; System.out.println("在哈希表中，没有找到该雇员~"); &#125; &#125; /** * 编写散列函数, 使用一个简单取模法 */ public int hashFun(int id) &#123; return id % size; &#125;&#125;class Emp &#123; public int id; public String name; /** * next 默认为null */ public Emp next; public Emp(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125;/** * 创建EmpLinkedList ,表示链表 */class EmpLinkedList &#123; /** * 头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp * 默认null */ private Emp head; /** * 添加雇员到链表 * 说明 * 1. 假定，当添加雇员时，id 是自增长，即id 的分配总是从小到大 * 因此我们将该雇员直接加入到本链表的最后即可 */ public void add(Emp emp) &#123; if (head == null) &#123; head = emp; return; &#125; // 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp = head; while (true) &#123; if (curEmp.next == null) &#123; // 说明到链表最后 break; &#125; // 后移 curEmp = curEmp.next; &#125; // 退出时直接将emp 加入链表 curEmp.next = emp; &#125; /** * 遍历链表的雇员信息 */ public void list(int no) &#123; if (head == null) &#123; // 说明链表为空 System.out.println("第" + (no + 1) + " 链表为空"); return; &#125; System.out.print("第" + (no + 1) + " 链表的信息为"); // 辅助指针 Emp curEmp = head; while (true) &#123; System.out.printf(" =&gt; id=%d name=%s\t", curEmp.id, curEmp.name); // 说明curEmp 已经是最后结点 if (curEmp.next == null) &#123; break; &#125; // 后移，遍历 curEmp = curEmp.next; &#125; System.out.println(); &#125; /** * 根据id 查找雇员 * 如果查找到，就返回Emp, 如果没有找到，就返回null * * @param id id */ public Emp findEmpById(int id) &#123; //判断链表是否为空 if (head == null) &#123; System.out.println("链表为空"); return null; &#125; //辅助指针 Emp curEmp = head; while (true) &#123; //找到 if (curEmp.id == id) &#123; //这时curEmp 就指向要查找的雇员 break; &#125; //退出 //说明遍历当前链表没有找到该雇员 if (curEmp.next == null) &#123; curEmp = null; break; &#125; //以后 curEmp = curEmp.next; &#125; return curEmp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Java数据结构和算法（排序算法）]]></title>
    <url>%2F%E9%87%8D%E5%AD%A6Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%89.html</url>
    <content type="text"><![CDATA[排序算法的介绍排序也称排序算法(Sort Algorithm)，排序是将一组数据，依照指定的顺序进行排列的过程。 排序的分类 内部排序法 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 外部排序法 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。 常见的排序算法分类 算法的时间复杂度度量一个程序(算法)执行时间的两种方法 事后统计的方法 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。 事前估算的方法 通过分析某个算法的时间复杂度来判断哪个算法更优。 时间频度 基本介绍一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 举例说明-基本案例比如计算1-100 所有数字之和, 我们设计两种算法： 举例说明-忽略常数项 结论： 2n+20 和2n 随着n 变大，执行曲线无限接近, 20 可以忽略。 3n+10 和3n 随着n 变大，执行曲线无限接近, 10 可以忽略。 举例说明-忽略常数低次项 结论： 2n2+3n+10 和2n2 随着n 变大, 执行曲线无限接近, 可以忽略3n+10。 n2+5n+20 和n2随着n 变大,执行曲线无限接近, 可以忽略5n+20。 举例说明-忽略系数 结论: 随着n 值变大，5n2+7n 和3n2 + 2n ，执行曲线重合, 说明这种情况下, 5 和3 可以忽略。 而n3+5n 和6n3+4n ，执行曲线分离，说明多少次方式关键。 时间复杂度 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n 的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 T(n) 不同，但时间复杂度可能相同。如：T(n)=n2+7n+6 与T(n)=3n2+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n2)。 计算时间复杂度的方法： 用常数1 代替运行时间中的所有加法常数T(n)=n2+7n+6 =&gt; T(n)=n2+7n+1 修改后的运行次数函数中，只保留最高阶项T(n)=n2+7n+1 =&gt; T(n) = n2 去除最高阶项的系数T(n) = n2 =&gt; T(n) = n2 =&gt; O(n2) 常见的时间复杂度 常数阶O(1) 对数阶O(log2n) 线性阶O(n) 线性对数阶O(nlog2n) 平方阶O(n2) 立方阶O(n3) k 次方阶O(nk) 指数阶O(2n) 常见的时间复杂度对应的图： 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 从图中可见，我们应该尽可能避免使用指数阶的算法。 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 。 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n) 说明： 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2) 。 O(log2) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 。 线性阶O(n) 说明： 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 。 线性对数阶O(nlogN) 说明： 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 。 平方阶O(n2) 说明： 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n2)，这段代码其实就是嵌套了2层n循环 ，它的时间复杂度就是 O(n2)，即 O(n2) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n) 。 立方阶O(n3)、K次方阶O(nk)说明： 参考上面的O(n2) 去理解就好了，O(n3)相当于三层n循环，其它的类似。 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图)。 算法的空间复杂度基本介绍 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n 的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n 有关，它随着n 的增大而增大，当n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法， 基数排序就属于这种情况。 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。 冒泡排序基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 思路分析 结论： 一共进行数组的大小-1 次大的循环 每一趟排序的次数在逐渐的减少 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 代码实现对数组[3, 9, -1, 10, -2]进行冒泡排序。 123456789101112131415161718192021public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; // 临时变量 int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag 判断元素是否进行过交换。从而减少不必要的比较。 12345678910111213141516171819202122232425262728293031public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; // 临时变量 int temp = 0; // 标识变量，表示是否进行过交换 boolean flag = false; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); if (!flag) &#123; // 在一趟排序中, 一次交换都没有发生过 break; &#125; else &#123; // 重置flag!!!, 进行下次判断 flag = false; &#125; &#125; &#125;&#125; 选择排序基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。 基本思想选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i 次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1 次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1 次，得到一个按排序码从小到大排列的有序序列。 思路分析 对一个数组的选择排序再进行讲解 代码实现对数组[101, 34, 119, 1]进行选择排序。 12345678910111213141516171819202122232425262728public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 说明假定的最小值，并不是最小 if (min &gt; arr[j]) &#123; // 重置min min = arr[j]; // 重置minIndex minIndex = j; &#125; &#125; // 将最小值，放在arr[i], 即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println("第" + (i + 1) + "轮后~~"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 插入排序基本介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。 基本思想插入排序（Insertion Sorting）的基本思想是：把n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 思路分析 代码实现对数组[101, 34, 119, 1]进行选择排序。 1234567891011121314151617181920212223242526272829303132public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; int insertValue = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) &#123; insertIndex = i - 1; insertValue = arr[i]; // 定义待插入的数 // 说明 // 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]) &#123; // 移位 排序过的元素右移一格 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; // 当退出while 循环时，说明插入的位置找到, insertIndex + 1 // 这里我们判断是否需要赋值 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertValue; &#125; System.out.println("第" + i + "轮插入"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 希尔排序简单插入排序存在的问题我们看简单的插入排序可能存在的问题。数组arr = {2,3,4,5,6,1} 这时需要插入的数1(最小), 这样的过程是： 123456&#123;2,3,4,5,6,6&#125;&#123;2,3,4,5,5,6&#125;&#123;2,3,4,4,5,6&#125;&#123;2,3,3,4,5,6&#125;&#123;2,2,3,4,5,6&#125;&#123;1,2,3,4,5,6&#125; 结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。 基本介绍希尔排序是希尔（Donald Shell）于1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 基本思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1 时，整个文件恰被分成一组，算法便终止。 思路分析 代码实现对数组[8,9,1,7,2,3,5,4,6,0]进行希尔排序。 123456789101112131415161718192021222324252627public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; int count = 0; // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素开始，逐个对每个组来排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j - gap]; j -= gap; &#125; //当退出while 后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; System.out.println("希尔排序第" + (++count) + "轮=" + Arrays.toString(arr)); &#125; &#125;&#125; 快速排序基本介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 思路分析 代码实现对数组[-9,78,0,23,-567,70]进行快速排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class QuickSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;-9, 78, 0, 23, -567, 70&#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; // 左索引 int l = left; // 右索引 int r = right; int pivot = arr[(left + right) / 2]; // 临时变量，作为交换时使用 int temp; // while 循环的目的是让比pivot的值小的放到左边，比pivot值大的放到右边 while (l &lt; r) &#123; // 在pivot的左边一直找,找到大于等于pivot的值,才退出 while (arr[l] &lt; pivot) &#123; l++; &#125; // 在pivot的右边一直找,找到小于等于pivot的值,才退出 while (arr[r] &gt; pivot) &#123; r--; &#125; // 如果l &gt;= r 说明pivot的左右两边的值，已经按照左边全部是小于等于pivot的值，右边全部是大于等于pivot的值 if (l &gt;= r) &#123; break; &#125; //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; // 如果交换完后，发现这个arr[l] == pivot 值相等r--， 前移 if (arr[l] == pivot) &#123; r--; &#125; // 如果交换完后，发现这个arr[r] == pivot 值相等l++， 后移 if (arr[r] == pivot) &#123; l++; &#125; // 如果l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) &#123; l++; r--; &#125; // 向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; // 向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125; &#125;&#125; 归并排序基本介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 基本思想 思路分析再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。 代码实现对数组[8,4,5,7,1,3,6,2]进行归并排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; //归并排序需要一个额外空间 int temp[] = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, temp); System.out.println("归并排序后=" + Arrays.toString(arr)); &#125; //分+合方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; //中间索引 int mid = (left + right) / 2; //向左递归进行分解 mergeSort(arr, left, mid, temp); //向右递归进行分解 mergeSort(arr, mid + 1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; &#125; /** * 合并的方法 * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; // 初始化i, 左边有序序列的初始索引 int i = left; // 初始化j, 右边有序序列的初始索引 int j = mid + 1; // 指向temp 数组的当前索引 int t = 0; // (一) // 先把左右两边(有序)的数据按照规则填充到temp数组 // 直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; // 继续 // 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 // 即将左边的当前元素，填充到temp 数组 // 然后t++, i++ if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t++; i++; &#125; else &#123; // 反之,将右边有序序列的当前元素，填充到temp 数组 temp[t] = arr[j]; t++; j++; &#125; &#125; // (二) // 把有剩余数据的一边的数据依次全部填充到temp while (i &lt;= mid) &#123; // 左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t++; i++; &#125; while (j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t++; j++; &#125; // (三) // 将temp 数组的元素拷贝到arr // 注意，并不是每次都拷贝所有 t = 0; int tempLeft = left; // 第一次合并tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tempLeft=0 right=3 // 最后一次tempLeft = 0 right = 7 while (tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t++; tempLeft++; &#125; &#125;&#125; 基数排序基本介绍 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法。 基数排序(Radix Sort)是桶排序的扩展。 基数排序是1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 思路分析将数组{53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。 代码实现对数组[53, 3, 542, 748, 14, 214]进行基数排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;53, 3, 542, 748, 14, 214&#125;; // 1. 得到数组中最大的数的位数 // 假设第一数就是最大数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; // 得到最大数是几位数 int maxLength = (max + "").length(); // 定义一个二维数组，表示10 个桶, 每个桶就是一个一维数组 // 说明 // 1. 二维数组包含10 个一维数组 // 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length // 3. 明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 // 可以这里理解 // 比如：bucketElementCounts[0] , 记录的就是bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; // 这里我们使用循环将代码处理 for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; // (针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位... for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的对应位的值 int digitOfElement = arr[j] / n % 10; // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k 个桶(即第k 个一维数组), 放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1 轮处理后，需要将每个bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第" + (i + 1) + "轮，排序处理arr =" + Arrays.toString(arr)); &#125; &#125;&#125; 基数排序的说明 基数排序是对传统桶排序的扩展，速度很快。 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成OutOfMemoryError 。 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，请参考这篇文章。 堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为O(nlogn)，它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意: 没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 大顶堆举例说明 小顶堆举例说明 一般升序采用大顶堆，降序采用小顶堆。 基本思想 将待排序序列构造成一个大顶堆。 此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大值。 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了。 思路分析要求：给定一个数组{4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。 步骤一构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组[4, 6, 8, 5, 9] 假设给定无序序列结构如下。 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。 找到第二个非叶节点4，由于[4,9,8]中9 元素最大，4 和 9 交换。 此时，我们就将一个无序序列构造成了一个大顶堆。 步骤二将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 将堆顶元素 9 和末尾元素 4 进行交换。 重新调整结构，使其继续满足堆定义。 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8。 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序。 总结 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HeapSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;4, 6, 8, 5, 9&#125;; heapSort(arr); System.out.println("排序后=" + Arrays.toString(arr)); &#125; public static void heapSort(int arr[]) &#123; int temp = 0; // 1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125; /* * 2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端; * 3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for (int j = arr.length - 1; j &gt; 0; j--) &#123; // 交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); &#125; &#125; /** * 将一个数组(二叉树), 调整成一个大顶堆 * &lt;p&gt; * 功能： 完成将以 i 对应的非叶子节点的树调整成大顶堆 * 举例int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到&#123;4, 9, 8, 5, 6&#125; * 如果我们再次调用adjustHeap 传入的是i = 0 =&gt; 得到&#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125; * * @param arr 待调整的数组 * @param i 表示非叶子节点在数组中索引 * @param length 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int length) &#123; // 先取出当前元素的值，保存在临时变量 int temp = arr[i]; //1. k = i * 2 + 1, k 是 i 节点的左子节点 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; // 说明左子节点的值小于右子节点的值 if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; // k 指向右子节点 k++; &#125; // 如果子节点大于父节点 if (arr[k] &gt; temp) &#123; // 把较大的值赋给当前节点 arr[i] = arr[k]; // !!! i 指向k,继续循环比较 i = k; &#125; else &#123; break; &#125; &#125; // 当for循环结束后，我们已经将以 i 为父节点的树的最大值，放在了最顶(局部) // 将 temp 值放到调整后的位置 arr[i] = temp; &#125;&#125; 常用排序算法总结和对比 相关术语解释： 稳定：如果a 原本在b 前面，而a=b，排序之后a 仍然在b 的前面； 不稳定：如果a 原本在b 的前面，而a=b，排序之后a 可能会出现在b 的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间； 空间复杂度：运行完一个程序所需内存的大小； n: 数据规模； k: “桶”的个数； In-place: 不占用额外内存； Out-place: 占用额外内存；]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建个人博客（Hexo篇）]]></title>
    <url>%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Hexo%E7%AF%87%EF%BC%89.html</url>
    <content type="text"><![CDATA[前言什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本教程使用的软件版本： win10（1903 版） git（2.22） node（10.15.3） hexo（3.9.0） 搭建步骤安装git访问git官网下载后完成安装，完成后右键会有git bash命令行出现，以后用这个命令行工具来操作git。推荐廖雪峰老师的git教程，可以用作入门。 安装后输入查看版本命令git --version来验证git是否已正常安装。 安装node访问node官网下载适合版本完成安装，完成后输入查看版本命令node-v和npm-v来验证git是否已正常安装。 安装cnpm因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以需要安装cnpm。 输入如下命令： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后输入查看版本命令cpnm -v验证是否已正常安装。 安装hexo输入如下命令： 1cnpm install -g hexo-cli 安装完成后依然通过查看版本命令hexo -v来验证是否已正常安装完成。 安装完成后开始进行初始化工作。 在本地磁盘建立博客文件夹，以我为例，在G盘建立blog文件夹。然后通过git bash或者cmd窗口进入到该文件夹，输入hexo init命令。 新建完成后可以发现hexo在文件夹下自动建立了如下目录： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的 配置 信息，我们在此会配置大部分的参数。 scaffolds：模版文件夹。当新建文章时，hexo会根据 scaffold 来建立文件。 source：资源文件夹。是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes：主题文件夹。hexo会根据主题来生成静态页面。 到此，安装基本完成了，下面我们来执行hexo s命令在本地启动看一下效果。 提示我们启动在了4000端口，可以通过Ctrl+C命令来终止服务。在浏览器输入http://localhost:4000就能看到生成的博客了。 写下第一篇文章下面介绍一下怎样完成一篇文章并发布。 在 blog 目录下输入hexo n &quot;我的第一篇文章&quot;命令来新建一篇文件。然后cd到 source/_post 目录，会发现hexo已经帮我们新建了我的第一篇文章.md文件，我们通过typora编辑该文件，完成第一篇文章。 下面回到blog目录，依次执行hexo clean和hexo generate命令来生成刚才编写的文章。 完成后，还是执行hexo s命令在本地查看一下我们刚才写的文章。 将hexo部署到github在github新建仓库。注意，仓库名称应该是用户名+.github.io，因为只有这样，部署到GitHub page时才会被识别。 本地安装hexo的git插件执行cpnm install hexo-deployer-git --save命令完成安装。 修改配置文件修改 blog 目录下的 _config.yml 文件，将git仓库地址和分支信息填上。 发布到github执行hexo d命令将本地文章同步到github。第一次需要输入github账号和密码。 执行完成后，可以看到已经同步到远端了。 到github仓库中查看一下，同样也发现文章已经同步过来了。 在浏览器输入http://yourname.github.io就能看到你的博客了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>零基础</tag>
        <tag>个人网站</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
